{"id": "aizpttoken", "name": "Aizpttoken", "chain_id": 56, "block_number": 42846997, "target_contract": "0xBe779D420b7D573C08EEe226B9958737b6218888", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-10/AIZPTToken_exp.sol", "defihacklabs_vuln_type": "Wrong Price Calculation", "exploit_file": "AIZPTToken_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1728120829, "native_token_price_usd": 562.94, "tags": [], "lost_amount_usd": 20000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Incorrect AMM reserve accounting and inconsistent swap math (buy uses post-deposit ETH balance; buy/sell formulas do not preserve an invariant)", "severity": "critical", "content": "The contract implements an internal \u201cAMM\u201d using the token contract\u2019s own ETH balance and its token balance as reserves, but the swap pricing is mathematically incorrect and inconsistent between buy() and sell(). In buy() (invoked from receive()), tokensOut is computed using address(this).balance as the ETH reserve denominator. Since ETH is credited to the contract before receive()/buy() executes, address(this).balance already includes msg.value (post-deposit reserve), so the function does not use pre-swap reserves. Separately, sell() uses a different formula to compute ETH out, and the two formulas do not maintain a constant-product invariant or any other consistent invariant/fee model. Additionally, sell() changes reserves asymmetrically by only moving part of the input tokens into the contract while burning the rest, yet pays ETH out as if reserves were updated under a standard swap formula. This combination enables reserve distortion across sequential swaps and allows an attacker to extract ETH via cyclic/repeated trades, ultimately draining the contract\u2019s ETH/BNB liquidity.", "fix_description": "Replace the custom pricing with a single invariant-based AMM formula using pre-swap reserves and explicit fees. For buy(), compute ethReserve as address(this).balance - msg.value (pre-swap) and calculate tokensOut using the same invariant used for sell(). For sell(), compute ethOut from amountInWithFee against pre-swap reserves and update reserves consistently. Do not burn part of the swap input/output unless it is incorporated as a standard fee that is reflected in the invariant math. Ensure getAmountOut() matches execution exactly.", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}, {"title": "Swap logic is implicitly triggered inside ERC20 transfer(to = address(this)), allowing unbounded repeated swaps without slippage/guardrails", "severity": "high", "content": "The token overloads ERC20 transfer() such that transfers to the token contract address are treated as sells and execute swap logic (sell()). This makes the swap entrypoint indistinguishable from a normal token transfer and prevents standard safety controls typically present in explicit swap functions (e.g., amountOutMin/deadline parameters, slippage checks, and clear integration boundaries). Because a caller can invoke transfer(address(this), amount) repeatedly in a single transaction, there is no practical limit on the number of sell executions or reserve updates that can be chained back-to-back. When combined with the flawed AMM math and asymmetric reserve changes, this design enables compounding value extraction across many sequential sells and accelerates depletion of the ETH reserve. Even after correcting the pricing, embedding swap behavior in transfer() remains hazardous because it can be triggered accidentally by integrations and makes it difficult to enforce user protection parameters.", "fix_description": "Remove swap side-effects from ERC20 transfer(). Provide explicit buy/sell functions (or a router-facing swap function) that take minOut and deadline parameters and enforce slippage checks. If a transfer-triggered sell must remain, restrict it (e.g., only callable by a trusted router/pair) and add per-tx limits and reentrancy protection.", "focus_areas": ["execution_flow", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:13:01.532296+00:00", "code_visible": true}}
{"id": "firetoken", "name": "Firetoken", "chain_id": 1, "block_number": 20869374, "target_contract": "0x18775475f50557b96C63E8bbf7D75bFeB412082D", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-10/FireToken_exp.sol", "defihacklabs_vuln_type": "Pair Manipulation With Transfer Function", "exploit_file": "FireToken_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1727770391, "native_token_price_usd": 2447.54, "tags": [], "lost_amount_usd": 20000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Sell path illegally burns tokens from the Uniswap pair balance and forcibly syncs reserves", "severity": "critical", "content": "On sells (when `to == uniswapV2Pair`), the token\u2019s `_transfer` contains non-standard logic that directly debits `_balances[uniswapV2Pair]` and credits the dead address for `sellAmount = amount - taxAmount`, then calls `IUniswapV2Pair(uniswapV2Pair).sync()`. This means the token contract can reduce (burn) the pair\u2019s token balance even though the pair contract did not initiate a transfer and did not consent to a burn. In effect, the token is able to \u201csteal\u201d assets from the AMM pool and then force the pool to accept the new balances as canonical reserves via `sync()`.\n\nThis breaks Uniswap V2\u2019s fundamental assumptions: reserves should only change via `mint/burn/swap` and should reflect real balances resulting from those operations. By manipulating the pair\u2019s balance and immediately syncing, the contract enables reserve/price distortion, allowing an attacker to create extreme price movements and extract the counter-asset (e.g., WETH) from the pool or otherwise destabilize/DoS trading. The conditional `liquidityPairBalance >= sellAmount` also makes behavior inconsistent as reserves drop, increasing unpredictability and exploit surface.", "fix_description": "Remove any logic that directly modifies `_balances[uniswapV2Pair]` (or any third-party address) outside normal ERC20 transfers. Specifically, delete the block that subtracts `sellAmount` from `uniswapV2Pair`, transfers it to `DEAD`, and calls `IUniswapV2Pair(uniswapV2Pair).sync()`. If a \u201csell burn\u201d is desired, implement it as a fee taken from the seller (`from`) during `_transfer` (burn from `from` or route to a fee collector) and let Uniswap reserves update naturally through standard swap flows. Never call `pair.sync()` from within token transfer logic.", "focus_areas": ["economic_attacks", "asset_management"], "auditable": true}, {"title": "Anti-contract buy restriction relies on extcodesize and is bypassable during contract construction", "severity": "medium", "content": "The contract attempts to block contract buys early in trading by enforcing `require(!isContract(to))` on buys (when `from == uniswapV2Pair` and `_buyCount < _preventSwapBefore`). The `isContract` helper uses `extcodesize(account)` to detect contracts. However, `extcodesize` returns 0 for contracts during their constructor, meaning a contract can buy tokens while it is being deployed and still pass this check.\n\nAs a result, any protection based on `!isContract(to)` is unreliable and provides a false sense of security. Attackers can automate complex multi-step interactions by performing buys inside constructors, undermining intended anti-bot restrictions. In the context of other high-impact issues (e.g., pool/reserve manipulation), this bypass removes friction that would otherwise slow or block scripted exploitation during the initial restricted period.", "fix_description": "Do not rely on `extcodesize`/`isContract` for security-critical gating. Remove the `require(!isContract(to))` restriction, or replace it with an explicit allowlist/phase-based mechanism (e.g., owner-managed allowlist for the first N blocks, signed access passes, per-block limits keyed to `from`, or router-level controls).", "focus_areas": ["business_logic", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:13:20.684710+00:00", "code_visible": true}}
{"id": "hydt", "name": "Hydt", "chain_id": 56, "block_number": 42985310, "target_contract": "0xA2268Fcc2FE7A2Bb755FbE5A7B3Ac346ddFeDB9B", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-10/HYDT_exp.sol", "defihacklabs_vuln_type": "Oracle Price Manipulation", "exploit_file": "HYDT_exp.sol", "evm_version": "cancun", "exploit_timestamp": 1728535784, "native_token_price_usd": 563.26, "tags": [], "lost_amount_usd": 5800.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Mint pricing relies on AMM spot reserves as an oracle (no TWAP / manipulation resistance)", "severity": "critical", "content": "The amount of HYDT minted in `InitialMintV2.initialMint()` is derived from `getCurrentPrice()`, which queries `DataFetcher.quote(...)` / `quoteRouted(...)` to compute a BNB\u2192USDT value using the current PancakeSwap pair reserves (i.e., a spot reserve ratio). This design treats the instantaneous AMM state as a trusted price oracle, but AMM reserves are not a reliable oracle input: they can be shifted significantly by large swaps and/or flash liquidity within the same block and then restored immediately after. Because the mint formula directly converts `msg.value` using this unprotected spot quote, any temporary distortion of the WBNB/USDT route causes the contract to misprice BNB and mint an incorrect amount of HYDT. The impact is direct loss of value: an attacker can obtain more HYDT than intended for the same BNB deposit, and then realize profit by swapping/selling the excess, while the protocol\u2019s reserve accounting remains consistent but economically drained. The existing daily/total mint caps only bound the maximum loss; they do not prevent the mispricing condition.", "fix_description": "Do not use `DataFetcher.quote/quoteRouted` (spot reserves) for mint pricing. Replace `getCurrentPrice()` with a manipulation-resistant oracle such as (a) Chainlink BNB/USD (and optionally USDT/USD) feeds with staleness checks, or (b) a PancakeSwap/Uniswap TWAP (cumulative price) over a sufficiently long observation window. Optionally enforce a max-deviation bound versus a trusted reference price to reject abnormal prices.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:12:47.538443+00:00", "code_visible": true}}
{"id": "sashatoken", "name": "Sashatoken", "chain_id": 1, "block_number": 20905301, "target_contract": "0xD1456D1b9CEb59abD4423a49D40942a9485CeEF6", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-10/SASHAToken_exp.sol", "defihacklabs_vuln_type": "Price Manipulation", "exploit_file": "SASHAToken_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1728203087, "native_token_price_usd": 2439.96, "tags": [], "lost_amount_usd": 600000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "swapTokensAtAmount is never initialized (defaults to 0), making swapBack trigger on essentially every eligible transfer", "severity": "critical", "content": "`swapTokensAtAmount` is declared but never set in the constructor and there is no setter. In Solidity this value defaults to `0`. The transfer path computes `canSwap` as `contractTokenBalance >= swapTokensAtAmount`; with a zero threshold this condition is always true (even when the contract holds 0 tokens). As a result, whenever `swapEnable` is on and the `auto1/auto2` pair-routing conditions match, `_transfer()` will attempt to enter `swapBack()` during normal user transfers.\n\nInside `swapBack()`, `tokensToSwap` is set to `contractBalance` and then capped to `swapTokensAtAmount`; because the threshold is zero, `tokensToSwap` becomes `0`, and `swapTokensForEth(0)` is invoked. This creates an unsafe and user-triggerable external DEX call from within `_transfer()` with an invalid/degenerate amount. Even if some router implementations revert on `amountIn=0`, this becomes a denial-of-service vector for transfers involving configured pair addresses. If it does not revert, it still introduces unintended external side effects during transfer execution, expanding the attack surface and enabling adversarial routing/manipulation around swap-on-transfer behavior.", "fix_description": "Initialize `swapTokensAtAmount` to a sensible non-zero value (e.g., in constructor) and/or add an `onlyOwner` setter with `require(newAmount > 0)`. Additionally, guard swap execution: compute `canSwap` as `swapTokensAtAmount > 0 && contractTokenBalance >= swapTokensAtAmount`, and in `swapBack()` early-return if `tokensToSwap == 0` before calling the router.", "focus_areas": ["execution_flow", "input_validation"], "auditable": true}, {"title": "Fee branching uses inconsistent if/else structure, allowing incorrect buy/sell classification and unintended swap/fee paths", "severity": "high", "content": "The fee logic in `_transfer()` is not a single mutually exclusive branch: it uses `if (auto1[to]) { ... }` followed by a separate `if (auto2[to]) { ... } else if (auto1[from]) { ... } else if (auto2[from]) { ... }`. Because the second condition is an independent `if`, the `else if` chain is associated only with `if (auto2[to])`, not with the prior `if (auto1[to])`.\n\nThis makes fee determination dependent on subtle combinations of flags on `from` and `to`. For example, when `auto1[to]` is true and `auto2[to]` is false, the code first sets a sell fee, then may immediately execute the `else if (auto1[from])` buy-fee branch and overwrite `fees`. More generally, an address\u2019 `auto1/auto2` status can cause transfers to be misclassified (buy vs sell) and can change whether swap/fee behavior is reached in `_transfer()`. This breaks the intended invariant that only transfers to an AMM pair are \u201csells\u201d and only transfers from an AMM pair are \u201cbuys\u201d, and it enables attacker-controlled routing to steer the token into unintended internal states during transfer execution.", "fix_description": "Rewrite fee calculation as a single, mutually exclusive decision: treat `(auto1[to] || auto2[to])` as sell, else if `(auto1[from] || auto2[from])` as buy. Consider consolidating to a single `isAMMPair` mapping to prevent contradictory flags and reduce attack surface.", "focus_areas": ["business_logic", "semantic_verification"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:13:11.854076+00:00", "code_visible": true}}
{"id": "morphoblue", "name": "Morphoblue", "chain_id": 1, "block_number": 20956051, "target_contract": "0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-10/MorphoBlue_exp.sol", "defihacklabs_vuln_type": "Overpriced Asset in Oracle", "exploit_file": "MorphoBlue_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1728815243, "native_token_price_usd": 2468.12, "tags": [], "lost_amount_usd": 230000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Market state keyed by `id` but calldata `MarketParams` are not validated against the stored market configuration", "severity": "critical", "content": "The protocol indexes essentially all market state (totals, positions, health checks, interest accrual) by `Id id = marketParams.id()`, but state-mutating entrypoints trust the caller-supplied `marketParams` as the authoritative configuration for that `id` (loan token, collateral token, oracle, IRM, LLTV) without verifying it matches the market that was originally created. Internally, several routines even document this as an assumption (e.g., they assume `marketParams` and `id` match), yet it is never enforced.\n\nAs a result, any call path that computes `id` from calldata and then uses other fields from that same calldata to (a) fetch prices, (b) compute collateralization limits, (c) compute liquidation seizure amounts, or (d) select the token addresses being transferred, can be executed under \u201cmarket confusion\u201d: the contract will read/write state for an existing market `id` while simultaneously using potentially different oracle/IRM/tokens/LLTV provided by the caller. This breaks core safety invariants around pricing and solvency and can allow borrowing/withdrawing collateral or liquidating under incorrect parameters, ultimately enabling loss of funds from the real market liquidity tied to that `id`.", "fix_description": "Bind `id` to immutable market configuration and enforce it for every entrypoint. Store canonical params (or a hash) at market creation, e.g. `idToMarketParams[id] = marketParams;`. Then, in every function receiving `MarketParams`, load the stored params and require equality of all fields (loanToken, collateralToken, oracle, irm, lltv). Preferably, remove `MarketParams` from user entrypoints entirely: accept only `Id` and always use `idToMarketParams[id]` internally for oracle/IRM/tokens/LLTV.", "focus_areas": ["input_validation", "business_logic"], "auditable": true}, {"title": "Reentrancy via user-controlled callbacks can manipulate positions before funds are pulled/pushed", "severity": "high", "content": "Multiple state-changing entrypoints invoke an external callback on `msg.sender` while the function is mid-execution and before the corresponding token transfer is finalized (e.g., supply/repay call back before `safeTransferFrom`; liquidate transfers collateral out and calls back before pulling repayment; flashLoan sends funds out, calls back, then pulls them back). This pattern violates checks-effects-interactions and creates a reentrancy surface where the callback can re-enter Morpho and perform additional actions against partially updated protocol state.\n\nBecause key invariants (shares minted vs. assets received; debt reduced vs. repayment received; collateral seized vs. repayment received; flash-loaned amount vs. amount returned) are only fully enforced after the callback and/or after the final transfer, a re-entrant caller can temporarily observe and exploit intermediate states to bypass intended sequencing assumptions, perform nested borrows/withdrawals/liquidations, or otherwise cause accounting-dependent checks to behave incorrectly. The code relies on non-enforced assumptions that external dependencies (tokens, oracles, IRM, callback receivers) will not re-enter, which is unsafe in permissionless environments and especially fragile in the presence of callback-capable tokens and attacker-controlled callback contracts.", "fix_description": "Add a `nonReentrant` guard to all external state-changing entrypoints (at least supply/withdraw/borrow/repay/supplyCollateral/withdrawCollateral/liquidate/flashLoan/accrueInterest/createMarket). Additionally, reorder operations to move required token pulls earlier (e.g., pull assets before minting shares where possible), and for liquidations collect `repaidAssets` before transferring seized collateral. Only execute callbacks after all transfers are complete and invariants are checked.", "focus_areas": ["reentrancy", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:13:42.489052+00:00", "code_visible": false}}
{"id": "vista", "name": "Vista", "chain_id": 56, "block_number": 43305237, "target_contract": "0x493361D6164093936c86Dcb35Ad03b4C0D032076", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-10/VISTA_exp.sol", "defihacklabs_vuln_type": "flashmint receive error", "exploit_file": "VISTA_exp.sol", "evm_version": "cancun", "exploit_timestamp": 1729495645, "native_token_price_usd": 598.48, "tags": [], "lost_amount_usd": 29000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Flash-mint/flash-burn flow is not covered by transfer restriction hooks (freeze/lock checks only applied to regular transfers)", "severity": "critical", "content": "The token enables ERC-3156 flash loans via OpenZeppelin\u2019s ERC20FlashMint, which repays by minting tokens to the borrower, executing the borrower callback, then burning the principal during repayment. If the token\u2019s freeze/lock/blacklist/\u201cfree balance\u201d restrictions are implemented only on standard transfer paths (e.g., in `_transfer` or in `_beforeTokenTransfer` with assumptions that `from != address(0)` and `to != address(0)`), those restrictions will not consistently apply to flash-mint and flash-burn operations. Minting (`from == address(0)`) and burning (`to == address(0)`) are distinct code paths and can bypass policies intended to prevent certain accounts from temporarily obtaining or using liquid balances.\n\nAny protocol component (e.g., presale/sale/redemption logic) that relies on `balanceOf`/`getFreeBalance`-style calculations as an invariant for eligibility, pricing, or payout becomes unsafe: a borrower can temporarily inflate usable balance via flash-mint, pass checks and extract value (e.g., receive a payout in another token), and still successfully repay because repayment is finalized through burn/allowance mechanics that do not trigger the intended transfer restrictions. This breaks the project\u2019s stated token restriction model and can enable direct loss of reserve assets held by related contracts within a single transaction.", "fix_description": "Enforce restriction checks for *all* token movement types, not only transfers between non-zero addresses. Specifically:\n- Override `_beforeTokenTransfer(from,to,amount)` (or the relevant OZ hook version in use) to apply freeze/lock checks when `from == address(0)` (mint) and/or `to == address(0)` (burn), or explicitly block flash mint/burn for restricted accounts.\n- Additionally/alternatively override `flashLoan(...)` to disallow flash loans to restricted receivers and ensure any \u201cfree balance\u201d accounting explicitly excludes flash-minted amounts.\nExample:\n```solidity\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n    if (from != address(0)) require(!frozen[from], \"from frozen\");\n    if (to != address(0)) require(!frozen[to], \"to frozen\");\n    // also enforce policy for mint/burn if restrictions are per-account\n    if (from == address(0)) require(!frozen[to], \"to frozen\");\n    if (to == address(0)) require(!frozen[from], \"from frozen\");\n    super._beforeTokenTransfer(from, to, amount);\n}\n\nfunction flashLoan(...) public override returns (bool) {\n    require(!frozen[address(receiver)], \"receiver frozen\");\n    return super.flashLoan(...);\n}\n```", "focus_areas": ["business_logic", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:12:24.065958+00:00", "code_visible": false}}
{"id": "labubu", "name": "Labubu", "chain_id": 56, "block_number": 44751944, "target_contract": "0x2fF960F1D9AF1A6368c2866f79080C1E0B253997", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-12/LABUBU_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "LABUBU_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1733836753, "native_token_price_usd": 677.28, "tags": [], "lost_amount_usd": 12048.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Non-standard balance top-up when balance hits zero enables unbounded inflation", "severity": "critical", "content": "The token implements non-standard logic in both `_transfer` and `_burn` that forcibly sets an account\u2019s balance to `16` whenever its post-operation balance becomes exactly zero:\n\n- In `_transfer`, after subtracting `amount` from `sender`, the code checks `if (_balances[sender] == 0) { _balances[sender] = 16; }`.\n- In `_burn`, after subtracting and reducing `_totalSupply`, it checks `if (_balances[account] == 0) { _balances[account] = 16; }`.\n\nThis behavior creates tokens out of thin air (an inflation backdoor), because those 16 units are not deducted from any other account and are not consistently reflected in `_totalSupply` (and in `_burn` supply is decreased while the burner\u2019s balance is re-increased). Any user can repeatedly transfer or burn their entire balance to reach exactly zero, receive 16 units \u201cfor free\u201d, move them out, and repeat\u2014minting unbounded tokens and breaking core ERC20/BEP20 invariants. This can enable value extraction from AMMs, break integrations relying on `totalSupply`, and undermine any economic assumptions about fixed supply.", "fix_description": "Remove the zero-balance crediting logic entirely.\n\n- Delete from `_transfer`:\n```solidity\nif (_balances[sender] == 0) {\n    _balances[sender] = 16;\n}\n```\n\n- Delete from `_burn`:\n```solidity\nif (_balances[account] == 0) {\n    _balances[account] = 16;\n}\n```\n\nEnsure transfers only move balances and burns only decrease both balance and `_totalSupply` without any hidden balance mutations.", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:12:38.837864+00:00", "code_visible": true}}
{"id": "pledge", "name": "Pledge", "chain_id": 56, "block_number": 44555337, "target_contract": "0x061944c0f3c2d7DABafB50813Efb05c4e0c952e1", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-12/Pledge_exp.sol", "defihacklabs_vuln_type": "Access Control", "exploit_file": "Pledge_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1733246836, "native_token_price_usd": 735.29, "tags": [], "lost_amount_usd": 15000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Treasury swap and liquidity management functions are publicly callable and allow arbitrary recipient selection", "severity": "critical", "content": "The contract exposes multiple treasury-management routines as `public` functions with no authorization checks, allowing any external account to move and convert assets held by the protocol. In particular, `swapTokenU(uint256 amount, address _target)` swaps `_token` held by the contract into USDT via the DEX router and sends the swap output to the caller-specified `_target`. There is no `onlyOwner`/role gating, no restriction that `_target` is a trusted treasury address, and no constraint that `amount` is tied to an authenticated user action. As a result, any user can drain protocol-held balances by swapping the contract\u2019s entire `_token` balance into USDT and directing proceeds to an attacker-controlled address. Related functions (`swapTokenForFund`, `swapToken`, `addLiquidityUsdt`) are also externally callable and can swap or lock/burn funds using the contract\u2019s balances, enabling theft or permanent loss of assets once the contract accumulates USDT or `_token` from normal operation. Additionally, repeated MAX approvals to the router amplify the impact by enabling ongoing swaps whenever funds are present.", "fix_description": "Restrict all swap/liquidity/treasury-moving functions to a trusted role (e.g., `onlyOwner` / `onlyTreasuryOperator`) and remove arbitrary recipient parameters. Swap outputs should be sent to `address(this)` or a hardcoded treasury address (not user-supplied). Prefer making these functions `internal` and callable only from validated user flows. Example changes: make `swapTokenU` `external onlyOwner` (or `internal`), delete `_target`, and set `to = address(this)`; similarly gate `swapTokenForFund`, `swapToken`, and `addLiquidityUsdt` and mint LP to a controlled address (not `_zero`).", "focus_areas": ["access_control", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:13:08.320247+00:00", "code_visible": true}}
{"id": "veth", "name": "Veth", "chain_id": 1, "block_number": 21184777, "target_contract": "0x280A8955A11FcD81D72bA1F99d265A48ce39aC2E", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-11/vETH_exp.sol", "defihacklabs_vuln_type": "Vulnerable Price Dependency", "exploit_file": "vETH_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1731573335, "native_token_price_usd": 3059.11, "tags": ["requires_unverified_contract"], "lost_amount_usd": 447000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "`takeLoan` allows unbacked minting based solely on `validFactories` trust (no collateral/reserve invariant enforced)", "severity": "critical", "content": "`takeLoan(address to, uint256 amount)` mints new VirtualToken balance via `_mint(to, amount)` and only updates an internal debt ledger (`_increaseDebt(to, amount)`). No underlying asset is transferred in, no collateral is locked, and no on-chain invariant ties outstanding supply/debt to any reserves held by the token contract. As a result, the system\u2019s solvency depends entirely on every address in `validFactories` behaving correctly and never calling `takeLoan` unless real value backs the minted tokens. This is a fragile trust boundary: if any \u201cvalid factory\u201d is buggy, misconfigured, upgradeable/replaceable, or exposes any attacker-reachable call path, an attacker can cause arbitrary uncollateralized mints to themselves. Because VirtualTokens are standard ERC20s, these unbacked tokens can be sold into external liquidity venues for real assets, shifting losses to LPs and/or the protocol and rendering the wrapper insolvent. The per-block mint cap (`MAX_LOAN_PER_BLOCK`) is only a rate-limit and does not prevent theft or insolvency once the call is reachable.\n", "fix_description": "Remove unbacked mint authority from factories. Enforce collateralization at the token level: require `takeLoan` to atomically receive/lock underlying (e.g., `transferFrom`/`msg.value`) before minting, or move borrowing into a dedicated lending module where collateral, LTV, liquidation, and reserve accounting are enforced. If factories must remain, restrict them to minting only against verifiable deposits into this contract and validate reserves before allowing any redemption/cash-out.", "focus_areas": ["access_control", "business_logic"], "auditable": true}, {"title": "Debt/transfer restriction is not a sound solvency control and can be bypassed by minting to unconstrained recipients", "severity": "high", "content": "The contract attempts to prevent borrowers from transferring away loaned tokens by checking in `_update` that `balanceOf(from) >= value + _debt[from]`, effectively making `debt[from]` a non-transferable \u201clocked\u201d portion. This is not a robust system-level protection because it only constrains addresses that have their `_debt` set, and it assumes that `takeLoan` always assigns debt to the same address that receives/must retain the minted tokens. Any factory mistake or attacker-controlled call path that causes minting to an address without the intended debt lock (or otherwise mis-assigns the debtor/recipient relationship) results in immediately transferable, unbacked ERC20s. Once transferable, they can be swapped/sold externally, extracting value and leaving bad debt recorded elsewhere (or not at all). Even when correctly assigned, this mechanism does not ensure collateralization or reserves; it merely attempts to limit transferability and therefore should not be relied upon as a primary safety property.\n", "fix_description": "Do not rely on balance-vs-debt heuristics for safety. If loaned tokens must be non-transferable, implement explicit locked-balance accounting that is atomically and immutably coupled to the minted recipient (and disallow factories from choosing arbitrary `to`). Preferably mint loaned amounts to an escrow/lending contract and only release them under verified conditions, or replace the pattern with standard lending where users borrow underlying against collateral and the wrapper token remains fully backed.", "focus_areas": ["business_logic", "semantic_verification"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:13:26.982120+00:00", "code_visible": false}}
{"id": "cloberdex", "name": "Cloberdex", "chain_id": 8453, "block_number": 23514450, "target_contract": "0x6A0b87D6b74F7D5C92722F6a11714DBeDa9F3895", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-12/CloberDEX_exp.sol", "defihacklabs_vuln_type": "Reentrancy", "exploit_file": "CloberDEX_exp.sol", "evm_version": "cancun", "exploit_timestamp": 1733818247, "native_token_price_usd": 4515.92, "tags": [], "lost_amount_usd": 501000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "burn() performs external hook/callback before finalizing internal accounting (CEI violation)", "severity": "critical", "content": "The vault/rebalancer burn flow invokes an external, user-influenced hook/strategy callback during execution of `burn()` while critical state (e.g., share/position accounting, reserves/settlement deltas) is not yet fully finalized. Because the callback target is not inherently trusted (it can be selected when opening/creating a market/position), the hook can reenter the contract and call `burn()` (or other sensitive paths) again against stale state from the first burn. This breaks the Checks-Effects-Interactions pattern: the contract \u201cinteracts\u201d (external call) before completing \u201ceffects\u201d (final state updates), enabling multiple withdrawals/settlements to be executed for the same claim. In practice, this can allow an attacker to withdraw assets more than once, drain vault-held tokens, or otherwise corrupt accounting, since the second call observes pre-burn balances/supply and bypasses intended one-time reductions.\n\nThis risk is especially acute anywhere the burn path transfers assets or settles balances based on intermediate state, as reentrancy can cause the same settlement to be applied multiple times before the first invocation completes.", "fix_description": "Refactor `burn()` to strictly follow CEI: (1) compute and validate outputs, (2) update all internal accounting (burn shares, decrement user position, update totalSupply/reserves, mark burn as consumed), then (3) perform any external interactions (hooks/strategy callbacks and token transfers). Add a `nonReentrant` guard to `burn()` and any function reachable from hook execution. If hooks must exist, only allow audited/whitelisted hook contracts and/or execute hooks only after all state is finalized.", "focus_areas": ["reentrancy", "execution_flow"], "auditable": true}, {"title": "Permissionless open() allows untrusted strategy/hook addresses, enabling attacker-controlled external execution in core flows", "severity": "high", "content": "`open()` permits arbitrary callers to configure/create markets/pools with an arbitrary `strategy` (hook/callback) address. This makes core lifecycle functions (e.g., mint/burn/rebalance paths that invoke the strategy) execute untrusted external code chosen by an attacker. Even if the protocol\u2019s internal logic is correct under benign hooks, executing attacker-controlled callbacks inside sensitive state transitions expands the attack surface dramatically: the strategy can reenter, grief, manipulate control flow, or exploit any temporary invariants during settlement, and it removes the assumption that callbacks are well-behaved.\n\nThis is an architectural trust boundary issue: the protocol treats the hook as an extension point but does not enforce trust/validation. As a result, any latent CEI/reentrancy bug in the surrounding flow becomes immediately exploitable because the attacker can always supply a malicious hook to trigger it. This also complicates reasoning about invariants and makes securing state transitions significantly harder.", "fix_description": "Restrict `open()` so only governance/owner (or a vetted factory) can set/create pools and assign strategies, or enforce a strict allowlist/registry of approved strategy/hook contracts. If permissionless pool creation is required, remove user-supplied hook targets (use immutable, protocol-controlled hooks) and ensure all hook execution occurs after final state updates with reentrancy protection.", "focus_areas": ["access_control", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:13:06.752796+00:00", "code_visible": false}}
{"id": "ast", "name": "Ast", "chain_id": 56, "block_number": 45964639, "target_contract": "0xc10E0319337c7F83342424Df72e73a70A29579B2", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/Ast_exp.sol", "defihacklabs_vuln_type": "Price-Manipulation", "exploit_file": "Ast_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1737475209, "native_token_price_usd": 692.24, "tags": [], "lost_amount_usd": 65000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Liquidity add/remove inference uses attacker-influenceable balance heuristics and can burn tokens from the AMM pair", "severity": "critical", "content": "The token attempts to infer \u201cliquidity add\u201d and \u201cliquidity remove\u201d operations inside `_transfer()` by calling `checkLiquidityAdd(from)` and `checkLiquidityRm(to)` when transfers involve the AMM pair. This design is unsafe because both signals are derived from mutable, attacker-influenceable state rather than authoritative LP mint/burn events.\n\n`checkLiquidityRm(to)` decides that liquidity was removed solely by comparing the recipient\u2019s current LP token balance to `lastBalance[to]`. However, `lastBalance` is not reliably initialized and is updated by `checkLiquidityAdd(from)` using a heuristic based on changes in the pair\u2019s USDT balance and LP `totalSupply`. Any third party can alter the pair\u2019s token balances (e.g., via direct token transfers), so the USDT delta heuristic can be triggered without an actual liquidity add and can incorrectly inflate `lastBalance` for arbitrary users.\n\nWhen `_transfer()` sees `from == uniswapV2Pair` (buy path) and `checkLiquidityRm(to)` returns true, the contract executes `_burn(from, amount)` where `from` is the AMM pair. Burning from the pair corrupts the pair\u2019s balance/reserve relationship, enabling reserve desynchronization, pool accounting breakage, and value extraction/griefing. This is a fundamental business-logic flaw in AMM integration.", "fix_description": "Remove balance-based liquidity detection from ERC20 transfers and never burn from the AMM pair based on inferred conditions.\n\nMinimal safe fix:\n- Delete/disable the branch in `_transfer()` that calls `checkLiquidityRm(to)` and executes `_burn(from, amount)` when `from == uniswapV2Pair`.\n- If liquidity-specific behavior is required, only apply it based on explicit, verifiable signals (e.g., trusted router-only paths) and/or track actual LP mint/burn by observing the LP token\u2019s `Transfer` events from/to `address(0)`; update `lastBalance[user]` only when the user\u2019s LP balance truly changes.\n- Do not use pair token balance deltas (e.g., USDT balance changes) as a proxy for liquidity operations.", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:13:46.906757+00:00", "code_visible": true}}
{"id": "ipc", "name": "Ipc", "chain_id": 56, "block_number": 45561315, "target_contract": "0xEAb0d46682Ac707A06aEFB0aC72a91a3Fd6Fe5d1", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/IPC_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "IPC_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1736265139, "native_token_price_usd": 697.99, "tags": [], "lost_amount_usd": 590000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Token transfer logic mutates AMM pair balance and forcibly calls `sync()`, enabling reserve/price desynchronization", "severity": "critical", "content": "The contract\u2019s deflationary mechanism `_destroy()` directly modifies the token balance held by the UniswapV2/Pancake pair (e.g., `balances[pair] -= burnNum`) and then calls `IUniswapV2Pair(pair).sync()` from within the ERC20 transfer flow. This is a fundamental design flaw for AMM-integrated tokens: an AMM\u2019s spot price is determined by its recorded reserves, which are expected to change only as a consequence of real transfers/swaps/liquidity operations. By burning tokens out of the pair and forcing a reserve update via `sync()`, the contract can artificially reduce the pair\u2019s token reserve without any corresponding inflow of the quote asset, shifting the pool price. Because `_destroy()` is reachable during ordinary user interactions (e.g., sells and, depending on branch conditions, even non-pair transfers once a pair exists), an untrusted actor can repeatedly trigger these burns and syncs to progressively move the pool price and extract the quote asset from the pool. This breaks the core constant-product assumptions and turns the pool into an economically manipulable oracle/venue.", "fix_description": "Do not burn (or otherwise mutate balances) from the AMM pair address, and do not call `pair.sync()` from token transfer logic. Remove the pair-balance decrement and `sync()` call inside `_destroy()`. If deflation is desired, burn only from the transacting amount (sender) or from fees held by the token contract itself (collected via actual transfers), never from LP reserves.", "focus_areas": ["economic_attacks", "business_logic"], "auditable": true}, {"title": "Anti-bot transfer timelock is sender-only and directionally applied, allowing easy bypass of intended cooldown", "severity": "high", "content": "The transfer cooldown is implemented by setting `transferTime[recipient] = block.timestamp` only on buys (when `sender == pair`), while enforcement is applied only when selling/transferring by checking the *sender* (`if (block.timestamp < transferTime[sender] + TRANSFER_LOCK) revert`). This design makes the protection per-address and asymmetric: only addresses that have recently received tokens in a buy are restricted from selling/transferring, while other addresses (including those that never had `transferTime` set) can sell immediately. As a result, the restriction can be bypassed by routing tokens through fresh/unlocked addresses or by using swap/callback flows that change the effective sender context. This does not prevent sophisticated, automated interaction patterns and therefore cannot be relied on as a safety mechanism to limit rapid repeated pool interactions\u2014especially dangerous when other transfer-side effects (e.g., burns/sync) are present.", "fix_description": "If a cooldown is required, enforce it consistently on all relevant interaction directions (buy, sell, and/or transfer) and base the restriction on a robust identifier (e.g., apply to both sender and recipient, or maintain a global/pair-interaction cooldown per address regardless of direction). Alternatively, remove the timelock entirely and eliminate reliance on it for economic safety by fixing the underlying AMM-reserve mutation issue.", "focus_areas": ["execution_flow", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:14:28.161370+00:00", "code_visible": false}}
{"id": "laura_token", "name": "Laura Token", "chain_id": 1, "block_number": 21529887, "target_contract": "0x05641E33Fd15BAf819729dF55500b07b82Eb8E89", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/LAURAToken_exp.sol", "defihacklabs_vuln_type": "Lack of Permission Check", "exploit_file": "LAURAToken_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1735737743, "native_token_price_usd": 3353.28, "tags": [], "lost_amount_usd": 41200.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Uniswap pair reserves can be unilaterally modified via direct balance mapping writes and sync()", "severity": "critical", "content": "The token directly mutates the ERC20 `_balances[uniswapV2Pair]` storage slot (i.e., the pair\u2019s token balance as tracked by this token contract) and then calls `IUniswapV2Pair.sync()` to force Uniswap to accept the new balance as the canonical reserve. In particular, `removeLiquidityWhenKIncreases()` reduces `_balances[uniswapV2Pair]` and then `pair.sync()`, and related paths in `handleTaxSellAndLpKValue(address)` can lead to this mechanism being triggered.\n\nThis is fundamentally unsafe because it bypasses Uniswap\u2019s intended liquidity mechanics (`mint`/`burn`) and violates the assumption that reserves only change through actual token transfers. A unilateral reduction of only one side of the pair breaks the constant product relationship between reserves and causes the pool price to become arbitrary relative to the other asset. Once `sync()` is called, the manipulated reserve becomes \u201creal\u201d for pricing, enabling extraction of the counter-asset from the pool and/or severe mispricing/DoS for normal trading.\n\nAdditionally, `removeLiquidityWhenKIncreases()` is publicly callable without authorization, so any user can trigger this reserve mutation whenever its internal condition is met, making the pool\u2019s solvency dependent on attacker-controlled timing.", "fix_description": "Remove all direct writes to `_balances[uniswapV2Pair]` and do not use `pair.sync()` to ratify unilateral balance changes. If liquidity must be adjusted, the contract should hold LP tokens and remove liquidity via the standard Uniswap flow (`IUniswapV2Pair.burn()` or router `removeLiquidity*`) so both assets are withdrawn proportionally. If the mechanism must remain, at minimum gate it behind strict access control (e.g., `onlyOwner`) and redesign it to only act on assets actually owned by the contract.", "focus_areas": ["asset_management", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:14:04.300092+00:00", "code_visible": true}}
{"id": "mosca2", "name": "Mosca2", "chain_id": 56, "block_number": 45722243, "target_contract": "0xd8791F0C10B831B605C5D48959EB763B266940B9", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/Mosca2_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "Mosca2_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1736748000, "native_token_price_usd": 688.37, "tags": [], "lost_amount_usd": 37600.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "withdrawFiat() redeems internal \u201ccredits\u201d for real stablecoins (asset/unit mismatch)", "severity": "critical", "content": "The contract tracks user value in multiple internal ledgers (e.g., `users[msg.sender].balance` and `balanceUSDT`/`balanceUSDC`). `join()`/`buy()` mint/update these ledgers using a derived `baseAmount = amount * 1000 / 1015` and additional fee/reward distribution that increases internal balances independently of the contract\u2019s actual USDT/USDC reserves. However, `withdrawFiat(uint256 amount, bool isFiat, uint8 fiatToWithdraw)` allows users to withdraw with `isFiat == false`, which debits `users[msg.sender].balance` (the generic \u201cMosca credits\u201d balance) but still transfers out real USDT/USDC (`usdt.transfer` / `usdc.transfer`) based on that debited amount. This creates a redeemability bug: balances that are not strictly backed 1:1 by on-chain stablecoins can be converted into actual USDT/USDC, allowing users to withdraw more stablecoins than they contributed and potentially drain pooled funds belonging to other users. This is a pure business-logic/accounting flaw (not mitigated by reentrancy guards) because the contract is effectively treating an internal accounting unit as a claim on external ERC20 reserves without enforcing solvency or asset segregation.", "fix_description": "Segregate balances by asset and enforce strict redemption rules:\n- If transferring USDT/USDC out, require `isFiat == true` and debit only `balanceUSDT`/`balanceUSDC`.\n- If `isFiat == false`, do not transfer USDT/USDC; instead transfer the actual \u201ccredit\u201d token (if any) or revert.\n- Ensure minting/crediting in `join()`/`buy()` cannot exceed net tokens retained by the contract (after all fees), and add an invariant/tests that total withdrawable USDT/USDC liabilities never exceed the contract\u2019s USDT/USDC balances.", "focus_areas": ["asset_management", "business_logic"], "auditable": true}, {"title": "Fee/referral distribution credits balances based on user-supplied amounts and can run with invalid upline, inflating internal claims", "severity": "high", "content": "`join()` unconditionally calls `distributeFees(msg.sender, amount)` (and similar flows call `distributeFees*`) and these functions credit internal balances (referrers, adminBalance, etc.) based on the input `amount`/derived `finalAmount`, not on the net stablecoins that remain in the contract after transfers to `feeReceiver` and other deductions. Additionally, the distribution logic assumes a meaningful referral chain via `referrers[user.collectiveCode]` but does not robustly enforce that a valid referrer/upline exists before crediting balances. The result is that internal balances can be incremented in ways that are not tightly coupled to actual token reserves and can be routed to unintended recipients (including zero-address user storage), further weakening solvency. While the core drain requires the withdrawal unit mismatch, this accounting design materially amplifies the over-redemption risk by allowing internal claims to grow faster than the contract\u2019s USDT/USDC holdings.", "fix_description": "Harden accounting in fee distribution:\n- In `distributeFees*`, if `referrer == address(0)`, skip upline credits (or route to a clearly defined sink) and do not dereference `users[referrer]`.\n- Compute fees/rewards from the net amount actually received/retained by the contract (post-fee transfers), not from the raw user parameter.\n- Add explicit solvency checks/invariants and events for all balance credits to facilitate auditing and monitoring.", "focus_areas": ["business_logic", "semantic_verification"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:15:17.218512+00:00", "code_visible": false}}
{"id": "mosca", "name": "Mosca", "chain_id": 56, "block_number": 45519929, "target_contract": "0x1962b3356122d6A56f978e112d14f5E23a25037D", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/Mosca_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "Mosca_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1736140963, "native_token_price_usd": 729.89, "tags": [], "lost_amount_usd": 19000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "withdrawAll() pays out internal ledgers without consistently debiting them and mixes multiple asset balances into a single-token payout", "severity": "critical", "content": "The contract tracks user entitlements across multiple internal ledgers (e.g., users[addr].balance, balanceUSDT, balanceUSDC) that are incremented by join()/buy() (including a discounted baseAmount computation) and by referral/cascade reward logic. However, withdrawAll() computes a single payout as the sum of all three ledgers and transfers that amount out in one token (preferring USDC if the contract has enough, otherwise USDT), effectively allowing conversion of any internal \u201cbalance type\u201d into whichever stablecoin liquidity is currently available at a 1:1 rate.\n\nMore critically, withdrawAll() does not clear or decrement user.balance / user.balanceUSDT / user.balanceUSDC when it transfers funds. exitProgram() calls withdrawAll(msg.sender) before performing any state updates, and afterwards only sets user.balance = 0 (leaving balanceUSDT/balanceUSDC intact). This breaks core accounting invariants: internal liabilities are not atomically settled against token transfers, enabling users to withdraw based on stale/uncleared ledgers and drain the contract\u2019s real USDT/USDC reserves.\n\nThis is a fundamental asset-management/accounting flaw: payouts are not tied to the specific asset deposited and balances are not debited at the time of withdrawal, making repeated or cross-asset extraction possible whenever the contract holds sufficient stablecoin liquidity.", "fix_description": "Refactor withdrawals to be per-asset and apply checks-effects-interactions: read each internal balance into local variables, set user.balance/user.balanceUSDT/user.balanceUSDC to 0 (or decrement precisely) BEFORE any external token transfer, then transfer the corresponding token amounts. Remove the \u201csum and pay in one token\u201d behavior; do not pay non-stablecoin internal balances in stablecoins unless explicitly backed/reserved. Ensure exitProgram() clears all relevant ledgers (including balanceUSDT and balanceUSDC) and consider adding nonReentrant protection to the external withdrawal entrypoint.", "focus_areas": ["asset_management", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:14:45.641310+00:00", "code_visible": true}}
{"id": "unilend", "name": "Unilend", "chain_id": 1, "block_number": 21608003, "target_contract": "0x4E34DD25Dbd367B1bF82E1B5527DBbE799fAD0d0", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/Unilend_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "Unilend_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1736679995, "native_token_price_usd": 3266.23, "tags": [], "lost_amount_usd": 195973.8, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Collateral/health-factor calculations incorrectly treat outstanding borrows as pool assets via virtual reserves", "severity": "critical", "content": "The pool computes a user\u2019s lend-position value from a \u201cvirtual reserve\u201d that includes both on-chain cash and outstanding borrows (e.g., `_totTokenBalance = IERC20(token).balanceOf(address(this)) + totalBorrow`). This value is then converted from shares using `getShareValue()` and fed directly into `userHealthFactorLtv()` / `userHealthFactor()` as the user\u2019s collateral.\n\nThis is a broken solvency model: `totalBorrow` is not a realizable asset held by the pool, yet it inflates the denominator used to value lender shares. As a result, collateral value used in health-factor checks does not decrease when the pool\u2019s real liquidity is withdrawn/borrowed (cash goes down, `totalBorrow` goes up, and their sum remains similar). Because `borrow()` itself increases `totalBorrow`, the protocol can end up approving additional borrows based on collateral whose valuation is maintained or boosted by newly-created debt.\n\nImpact: users can pass LTV/health checks and borrow out more real assets than the pool can support, leading to insolvency and allowing extraction of essentially all available liquidity while still appearing collateralized per the protocol\u2019s own accounting.", "fix_description": "Do not use `balanceOf(this) + totalBorrow` as the basis for collateral/health-factor calculations. For collateral valuation, derive lend balances from realizable assets only (e.g., `balanceOf(this)`), or use a properly designed interest-bearing index/exchange-rate model (cToken-style) where share value changes via accrued interest and borrowing cannot keep collateral constant. Concretely, in `userBalanceOftoken0/1` (or in dedicated collateral-value helpers used by health checks), replace `_totTokenBalance = balanceOf + totalBorrow` with a cash-based or index-based value that cannot be inflated by increasing `totalBorrow`.", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:14:51.607793+00:00", "code_visible": false}}
{"id": "alkimiya_io", "name": "Alkimiya Io", "chain_id": 1, "block_number": 22146339, "target_contract": "0xf3F84cE038442aE4c4dCB6A8Ca8baCd7F28c9bDe", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/Alkimiya_io_exp.sol", "defihacklabs_vuln_type": "unsafecast", "exploit_file": "Alkimiya_io_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1743176075, "native_token_price_usd": 1896.15, "tags": [], "lost_amount_usd": 95500.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Unsafe narrowing cast truncates share supply accounting (uint256 -> uint128) causing ERC1155 balances to diverge from pool state", "severity": "critical", "content": "`_collateralizedMint()` accepts `shares` as a `uint256` and mints ERC1155 long/short positions using the full `shares` value. However, the pool\u2019s internal supply accounting is tracked in `PoolState.sharesMinted` as a `uint128` and is updated via an unchecked narrowing cast: `sState.sharesMinted += uint128(shares);`. In Solidity, casting a `uint256` to `uint128` does not revert on overflow; it truncates modulo 2^128. As a result, callers can pass `shares > type(uint128).max` and mint an extremely large ERC1155 balance while only incrementing `sharesMinted` by a much smaller truncated amount. This breaks the core invariant that pool state supply matches token supply and makes any logic that relies on `sharesMinted` as the denominator (e.g., proportional collateral refunds and long/short redemption payouts) economically unsafe. In the worst case, a user can obtain an outsized claim on pool collateral/payout tokens relative to recorded supply and drain assets held by the contract for that pool (and potentially any shared token balances, depending on the escrow model).", "fix_description": "Enforce an upper bound and use SafeCast for all narrowing conversions. Prefer changing the API to `uint128 shares` (and similarly for any other uint128-tracked quantities) so invalid values are unrepresentable. Otherwise, add an explicit check and cast safely before mutating state:\n\n- `if (shares > type(uint128).max) revert InvalidShares(shares);`\n- `uint128 shares128 = SafeCast.toUint128(shares);`\n- `sState.sharesMinted += shares128;`\n\nAlso review other `uint128` state updates (e.g., `collateralMinted`) to ensure no similar truncation can occur from `uint256` intermediates.", "focus_areas": ["arithmetic", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:15:07.745686+00:00", "code_visible": false}}
{"id": "h2o", "name": "H2O", "chain_id": 56, "block_number": 47454898, "target_contract": "0xe9c4D4f095C7943a9ef5EC01AfD1385D011855A1", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/H2O_exp.sol", "defihacklabs_vuln_type": "Weak Random Mint", "exploit_file": "H2O_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1741946344, "native_token_price_usd": 587.88, "tags": [], "lost_amount_usd": 22470.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Balance inflation bug: subtracts `toSub` but credits full `amount`", "severity": "critical", "content": "The ERC20 accounting in `_transfer` is internally inconsistent and can violate balance conservation. The function computes a variable `toSub` (intended to be the amount debited from `from`) and later credits `to` with `amount` unconditionally. While `toSub` is initially set to `amount`, it can be modified by an obfuscated inline-assembly branch (`isMax`) that compares `sha256(abi.encodePacked(from))` to a stored constant `max`. When that branch is hit, `toSub` is clamped to `min(amount, bal)`. The subsequent check is `require(bal >= toSub)`, which will still pass even if `amount > bal` (because `toSub` may have been reduced to `bal`). As a result, the sender can be debited by less than the amount credited to the recipient, effectively minting tokens \u201cout of thin air\u201d.\n\nThis breaks fundamental ERC20 invariants (e.g., sum of balances tracking total supply) and can catastrophically impact integrations, especially AMMs and lending protocols that assume transfers cannot create value. A privileged/triggering sender can inflate balances, distort pool balances/reserves, and drain counterpart assets from liquidity pools.", "fix_description": "Remove the hidden `isMax`/`max` logic and enforce strict accounting: always require `balance >= amount`, debit exactly `amount`, and credit exactly `amount`. Concretely: delete the assembly block and `toSub`; use `require(_balances[from] >= amount)` then `_balances[from] -= amount; _balances[to] += amount; emit Transfer(from,to,amount);`. Prefer OpenZeppelin\u2019s ERC20 implementation and add invariant tests (e.g., conservation checks in fuzz/property tests).", "focus_areas": ["semantic_verification", "arithmetic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:14:38.481971+00:00", "code_visible": true}}
{"id": "uni", "name": "Uni", "chain_id": 1, "block_number": 21992033, "target_contract": "0x76EA342BC038d665e8a116392c82552D2605edA1", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/UNI_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "UNI_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1741314611, "native_token_price_usd": 2140.93, "tags": [], "lost_amount_usd": 14000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Permissionless skim()/sync() allows reserve poisoning when paired with non-standard ERC20 balance semantics", "severity": "critical", "content": "The pair exposes `skim(address)` and `sync()` as permissionless functions that directly interact with the contract\u2019s core accounting (`reserve0`, `reserve1`) via on-chain balances. This design inherits Uniswap V2 assumptions that both assets are \u201cstandard\u201d ERC20s whose balances only change through explicit transfers and whose `transfer` moves the exact requested amount.\n\nWhen either token has non-standard balance semantics (fee-on-transfer/deflationary, reflection, rebasing, or other mechanics that can cause the pair\u2019s `balanceOf` to diverge from stored reserves without a symmetric user action), the invariant model breaks: (1) `skim()` can be used to arbitrarily redistribute \u201cexcess\u201d tokens (balance \u2212 reserve) created by these mechanics, and (2) `sync()` can be used to permanently crystallize manipulated balances into reserves. Because `swap()` prices trades using reserves and balance deltas, poisoning reserves enables swaps at incorrect prices and value extraction from the counter-asset, harming LPs and draining the pool.\n\nThis is not a generic issue for Uniswap V2 under its intended token assumptions; it becomes critical when deploying this pair against tokens whose balances can change implicitly or transfer less/more than requested, while still allowing anyone to call `skim()`/`sync()`.\n", "fix_description": "Do not deploy this pair with rebasing/reflection/fee-on-transfer tokens; enforce a factory-level allowlist/blocklist for supported token types. If such tokens must be supported, deploy a specialized pair implementation designed for non-standard ERC20 semantics.\n\nAs a centralized mitigation, restrict reserve-affecting maintenance functions:\n- Add access control so only factory/governance can call `skim()` and `sync()`.\n\nExample:\n```solidity\nmodifier onlyFactoryOrGov() {\n    require(msg.sender == factory || msg.sender == IUniswapV2Factory(factory).feeToSetter(), \"FORBIDDEN\");\n    _;\n}\n\nfunction skim(address to) external lock onlyFactoryOrGov { ... }\nfunction sync() external lock onlyFactoryOrGov { ... }\n```\n", "focus_areas": ["economic_attacks", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:14:43.624838+00:00", "code_visible": false}}
{"id": "pump", "name": "Pump", "chain_id": 56, "block_number": 47169115, "target_contract": "0x09762e00Ce0DE8211F7002F70759447B1F2b1892", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/Pump_exp.sol", "defihacklabs_vuln_type": "Not Slippage Protection", "exploit_file": "Pump_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1741088929, "native_token_price_usd": 583.83, "tags": [], "lost_amount_usd": 6400.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "initialize() is externally callable without access control, allowing permanent takeover of critical configuration", "severity": "critical", "content": "The contract relies on an external `initialize(address manager_, address ipshareSubject_, string tick)` function to set all security-critical configuration (e.g., `manager`, `bondingCurve = IBondingCurve(manager_)`, `ipshareSubject`) and to create the AMM `pair` using addresses fetched from `IPump(manager)` (router/factory/WETH, fee receiver/ratios, etc.). However, `initialize()` is `public` and the only protection is an `initialized` boolean, meaning the first account to call it permanently controls these parameters.\n\nThis enables a hostile initialization where an attacker sets `manager_` to a malicious contract that returns attacker-chosen router/factory/pair and fee parameters and provides arbitrary bonding-curve pricing/amounts. Since subsequent user flows (`buyToken`, `sellToken`, auto-buy in `receive()`, and liquidity listing) trust these dependencies, the attacker can redirect ETH/WETH flows, manipulate pair creation and listing behavior, and otherwise break economic and safety assumptions. This is a full contract takeover risk whenever deployment and initialization are not performed atomically by a trusted party (or can be front-run).", "fix_description": "Restrict initialization to a trusted deployer/factory and/or make deployment+initialization atomic. For example: store an immutable `factory` in the constructor and `require(msg.sender == factory)` in `initialize()`, or use `Ownable` and protect `initialize()` with `onlyOwner`. Additionally validate `manager_` against an allowlist/registry and sanity-check router/factory/WETH addresses for the target chain.", "focus_areas": ["access_control", "upgradeable_contracts"], "auditable": true}, {"title": "buyToken() allows arbitrary receiver during pre-listing, including the AMM pair, enabling liquidity initialization state to be corrupted", "severity": "high", "content": "Before `listed` is true, `buyToken()` allows the caller to choose an arbitrary `receiver` (defaulting only when `receiver == address(0)`), and does not forbid sending purchased tokens to system-critical addresses such as the AMM `pair`. This permits tokens to be transferred directly into the pair during the bonding-curve phase, outside of the intended liquidity provisioning/minting flow.\n\nThis is dangerous because `_makeLiquidityPool()` later seeds liquidity using a fixed `liquidityAmount` of tokens from the token contract and the contract\u2019s ETH balance, without accounting for any pre-existing token balance sitting in the pair. Allowing the pair to be preloaded with tokens can distort initial reserves/pricing and LP minting assumptions, and makes the listing/initial-trading state manipulable by external users. The issue is fundamentally an input/recipient validation flaw: the contract treats the receiver as an arbitrary destination even though certain destinations must be disallowed to preserve AMM initialization invariants.", "fix_description": "During the unlisted/bonding-curve phase, disallow `receiver` values that can affect listing invariants (at minimum `pair`, `address(this)`, and optionally other protocol addresses): `require(receiver != pair && receiver != address(this), \"invalid receiver\");`. Alternatively remove arbitrary receivers pre-listing (force `receiver = msg.sender`), and/or on listing enforce `balanceOf(pair) == 0` (or create the pair only at listing time and ensure it is empty).", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:15:20.812494+00:00", "code_visible": true}}
{"id": "btnft", "name": "Btnft", "chain_id": 56, "block_number": 48472355, "target_contract": "0x0FC91B6Fea2E7A827a8C99C91101ed36c638521B", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-04/BTNFT_exp.sol", "defihacklabs_vuln_type": "Claim Rewards Without Protection", "exploit_file": "BTNFT_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1744999249, "native_token_price_usd": 591.73, "tags": [], "lost_amount_usd": 19025.919331278623, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "ERC721 transferFrom override breaks standard authorization checks", "severity": "critical", "content": "The contract\u2019s ERC721 `transferFrom(address from, address to, uint256 tokenId)` implementation (or the internal transfer helper it relies on) does not correctly enforce the ERC721 authorization invariant that only the token owner, an approved address for `tokenId`, or an approved operator may transfer a token. In OpenZeppelin v5, `transferFrom` routes through `_update(to, tokenId, _msgSender())` and `_update` calls `_checkAuthorized(from, auth, tokenId)`. If the project override bypasses this by passing a zero/incorrect `auth` value into `_update`, or by calling internal transfer logic without `_checkAuthorized`, then any caller can move any NFT by supplying the current `from` address (retrievable via `ownerOf`).\n\nImpact: complete loss of NFT custody guarantees. An attacker can arbitrarily transfer users\u2019 NFTs (including sweeping many tokenIds) into an attacker-chosen destination (e.g., the BTNFT contract itself), which can cascade into theft of associated rewards/settlement assets and irrecoverable user losses.\n\nThis is a fundamental standards-violation that invalidates downstream assumptions about token ownership and approvals across the entire system.", "fix_description": "Remove/modify the override so transfers always enforce OZ authorization:\n- Use OZ\u2019s pattern: `address prev = _update(to, tokenId, _msgSender());` and do not bypass `_checkAuthorized`.\n- If custom transfer paths are required (staking/admin recovery), add explicit access control and/or require `_isAuthorized(ownerOf(tokenId), msg.sender, tokenId)` before transferring.", "focus_areas": ["access_control", "asset_management"], "auditable": true}, {"title": "Reward/settlement logic improperly relies on contract-held NFT ownership without authenticated depositor attribution", "severity": "high", "content": "The reward/settlement mechanism appears to treat NFTs held by the BTNFT contract as eligible positions for reward accrual and/or payout, without binding each tokenId to a specific authenticated depositor/beneficiary established at deposit time. If reward calculation/claiming uses conditions like \u201cNFT is owned by this contract\u201d (or iterates contract-owned NFTs) and then credits `msg.sender` or otherwise fails to resolve the original owner, unsolicited or externally-induced custody changes can create claimable rewards for an arbitrary caller.\n\nThis breaks a core business invariant: rewards must only be claimable by the rightful position owner and only for voluntarily created positions. When combined with any ability to move NFTs into contract custody without a corresponding deposit record (including non-standard transfers), an attacker can manufacture reward-eligible positions and extract the reward token supply or treasury funds.\n\nEven if custody is intended (staking), relying on `ownerOf(tokenId)` after custody transfer is insufficient because ownership becomes the contract, and without a `tokenId -> beneficiary` mapping the system cannot safely determine who should receive rewards.", "fix_description": "Introduce explicit deposit state and beneficiary attribution:\n- Add `mapping(uint256 => address) depositor;`\n- Implement `deposit(tokenId)` requiring owner/approval, transferring the NFT to the contract, and setting `depositor[tokenId] = msg.sender`.\n- In claim/settle, require `depositor[tokenId] != address(0)` and pay only `depositor[tokenId]`.\n- Do not auto-enroll rewards on unsolicited transfers; if `onERC721Received` is used, require intent data/signature and set beneficiary during deposit.", "focus_areas": ["business_logic", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:15:28.717029+00:00", "code_visible": false}}
{"id": "lifeprotocol", "name": "Lifeprotocol", "chain_id": 56, "block_number": 48703545, "target_contract": "0x42e2773508e2AE8fF9434BEA599812e28449e2Cd", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-04/Lifeprotocol_exp.sol", "defihacklabs_vuln_type": "Price Manipulation", "exploit_file": "Lifeprotocol_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1745692987, "native_token_price_usd": 607.36, "tags": [], "lost_amount_usd": 15114.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Buy/sell pricing is not derived from a consistent reserve/supply invariant (manual price ratchet enables risk-free arbitrage)", "severity": "critical", "content": "The protocol\u2019s pricing and accounting logic does not enforce any invariant that links (i) the USDT paid/received, (ii) token inventory state (`remainingSupply`, `queueSupply`), and (iii) the quoted `currentPrice`. In `buy()`, the contract computes a total USDT cost and then updates `currentPrice` via `handleRatio(totalUsdtCost)`, which ultimately increases `currentPrice` using `calculatePriceIncrease(_amount)` based on trade notional. This is a manual, monotonic \u201cprice ratchet\u201d that is not the marginal price paid for the purchased tokens (i.e., it is not the integral under a bonding curve) and is not derived from reserves like an AMM. Conversely, `sell()` prices redemptions at `currentPrice * 90%`, meaning the sell price is a direct function of this artificially increased `currentPrice`, not of the contract\u2019s ability to pay based on consistent economics. Because buy-side payment is not symmetric with sell-side valuation around the same curve/invariant, there exist deterministic sequences of buys and sells that yield positive expected profit and can drain the contract\u2019s USDT balance (limited only by available liquidity/limits), without requiring price movement from an external market.", "fix_description": "Replace `currentPrice` mutation (`handleRatio`/`calculatePriceIncrease`) with an invariant-based pricing model:\n- Either implement a proper bonding curve where buy cost is computed as the integral of the marginal price function over the purchased token amount and update price/supply accordingly; and compute sell proceeds using the same curve (minus an explicit fee).\n- Or derive `currentPrice` solely from on-chain reserves/supply (e.g., constant-product with virtual reserves) and never manually increment it.\nAt minimum: remove `calculatePriceIncrease(_amount)`-based updates and ensure buy and sell quote prices from the same formula such that no buy\u2192sell loop can be profitable after fees.", "focus_areas": ["economic_attacks", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:15:35.955570+00:00", "code_visible": false}}
{"id": "krc_token_pair", "name": "KRC Token Pair", "chain_id": 56, "block_number": 49875423, "target_contract": "0xdBEAD75d3610209A093AF1D46d5296BBeFFd53f5", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-05/KRCToken_pair_exp.sol", "defihacklabs_vuln_type": "Precision loss", "exploit_file": "KRCToken_pair_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1747556506, "native_token_price_usd": 651.71, "tags": ["skim_desync_attack", "hardcoded_amounts"], "lost_amount_usd": 7000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Pair accounting assumes standard ERC-20 transfers; fee-on-transfer/rebasing tokens can desynchronize reserves and balances", "severity": "critical", "content": "The pair is a UniswapV2-style implementation that implicitly assumes value-preserving ERC-20 semantics: transferring X tokens into/out of the pair changes the pair\u2019s `balanceOf()` by exactly X, and token balances only change via transfers. This assumption is embedded in multiple places: (1) `swap()` infers `amount0In/amount1In` from the post-swap balances relative to cached `reserve0/reserve1`, then applies the constant-product check using those inferred deltas; (2) `skim()` allows sending `balance - reserve` to an arbitrary address; and (3) reserves are only updated in `_update()` (called at the end of `swap/mint/burn/sync`), so cached reserves can remain stale while actual balances move.\n\nIf either token charges transfer fees, rebases, or otherwise changes balances non-linearly, the pair\u2019s cached reserves and actual balances can diverge in attacker-influenced ways. This breaks the invariant assumptions used for pricing and can enable value extraction from the other asset in the pool (or cause DoS via invariant failures). The presence of an unrestricted `skim()` further amplifies this by providing a direct primitive to repeatedly realize and redirect `balance - reserve` during reserve/balance divergence.\n", "fix_description": "Do not use a vanilla V2 pair with fee-on-transfer/rebasing/reflective tokens. Enforce this at the factory/router via an allowlist or a dedicated \u201csupporting fee-on-transfer\u201d pair design that measures actual received amounts and updates reserves safely. Additionally, restrict or remove `skim()` (e.g., only factory/keeper callable), and/or require `sync()`/reserve refresh before swaps when interacting with non-standard tokens. If attempting on-chain enforcement, add checks rejecting tokens whose `transfer(amount)` does not change the recipient balance by `amount` in controlled test transfers (typically done in factory/router, not in the pair).", "focus_areas": ["economic_attacks", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:15:40.979084+00:00", "code_visible": true}}
{"id": "bankroll_network", "name": "Bankroll Network", "chain_id": 56, "block_number": 51715417, "target_contract": "0xAdEfb902CaB716B8043c5231ae9A50b8b4eE7c4e", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-06/BankrollNetwork_exp.sol", "defihacklabs_vuln_type": "Incorrect input validation", "exploit_file": "BankrollNetwork_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1750317289, "native_token_price_usd": 644.83, "tags": [], "lost_amount_usd": 15798.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Dividend reserve accounting is decoupled from the contract\u2019s actual ERC20 balance (untracked balance can be withdrawn as dividends)", "severity": "critical", "content": "The contract pays user dividends in an external ERC20 based on internal accounting (profitPerShare_, tokenBalanceLedger_, payoutsTo_). However, the actual ability to pay is determined by the contract\u2019s real token balance (token.balanceOf(address(this))). The contract also maintains a separate internal \u201creserve\u201d variable (dividendBalance_) that is intended to represent distributable tokens, but this variable is not reconciled against the real on-chain token balance and is not decremented when users withdraw dividends.\n\nAs a result, the system can enter a state where the contract holds more (or less) ERC20 tokens than its internal accounting expects. In particular, tokens can be transferred directly to the contract address (outside buyFor/donatePool), increasing token.balanceOf(this) without increasing dividendBalance_. Because withdraw() transfers the dividend amount calculated from the ledger without bounding it by dividendBalance_ (and without decrementing dividendBalance_), any untracked token balance sitting in the contract can be \u201cconverted\u201d into withdrawable dividends if the attacker can make the ledger show a claimable amount. This breaks core solvency assumptions and enables draining of contract-held collateral.\n\nImpact: insolvency of the dividend pool and potential full loss of tokens held by the contract.\n", "fix_description": "Unify accounting with the actual ERC20 balance.\n\n- Track an `accountedBalance` and on every relevant state change (buy/sell/reinvest/withdraw/distribute/donate) reconcile newly received tokens:\n  - `uint256 actual = token.balanceOf(address(this));`\n  - `uint256 delta = actual - accountedBalance;` (handle actual < accountedBalance)\n  - `dividendBalance_ += delta; accountedBalance = actual;`\n- In withdraw(), enforce and update reserves:\n  - `require(dividendBalance_ >= dividends, \"INSUFFICIENT_DIVIDEND_RESERVE\");`\n  - `dividendBalance_ -= dividends; accountedBalance -= dividends;`\n- In general, compute distributable amounts from measured balance deltas rather than trusting a standalone mutable reserve variable.\n", "focus_areas": ["asset_management", "business_logic"], "auditable": true}, {"title": "Time-based dividend distribution is triggered by arbitrary user actions, allowing attacker-controlled profitPerShare_ updates", "severity": "high", "content": "distribute() updates profitPerShare_ based on elapsed time and dividendBalance_, and it is invoked as a side effect of multiple user-controlled entrypoints (buy/buyFor/sell/reinvest/withdraw). Because distributionInterval is very small and the function is callable implicitly through common actions, any user can force distribution updates at chosen moments, including multiple times across a short period and within complex transaction flows.\n\nThis design makes the global dividend accumulator (profitPerShare_) attacker-steerable rather than a passive reflection of organic fee accrual. When profitPerShare_ can be advanced/updated on demand, an attacker can shape the ordering of state transitions that affect tokenSupply_, tokenBalanceLedger_, payoutsTo_, and profitPerShare_ to concentrate a disproportionate share of the distributed amount to themselves.\n\nOn its own, time-based dripping is not necessarily unsafe, but coupling it to arbitrary user calls without stronger invariants (and without reconciling reserves to actual balances) creates a manipulable execution flow where distribution can be induced precisely when it benefits a specific holder state.\n", "fix_description": "Decouple distribution from arbitrary user calls and harden update invariants:\n\n- Make distribute() callable only by a trusted automation role/keeper, or execute it on a fixed schedule off user actions.\n- Enforce one update per block/time step (e.g., `require(block.timestamp > lastPayout)` and/or `require(block.number > lastPayoutBlock)`).\n- Ensure distribution uses reconciled/verified reserves (see previous finding) so profitPerShare_ can only increase based on accounted, actually-held tokens.\n", "focus_areas": ["execution_flow", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:16:27.151832+00:00", "code_visible": false}}
{"id": "bankroll_stack", "name": "Bankroll Stack", "chain_id": 56, "block_number": 51698203, "target_contract": "0x16d0a151297a0393915239373897bCc955882110", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-06/BankrollStack_exp.sol", "defihacklabs_vuln_type": "Incorrect input validation", "exploit_file": "BankrollStack_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1750291467, "native_token_price_usd": 644.83, "tags": [], "lost_amount_usd": 5000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Token transfers are accounted as nominal amounts instead of actual balance deltas (fee-on-transfer/rebasing incompatibility)", "severity": "critical", "content": "The contract assumes the underlying `token` behaves like a vanilla ERC20 where `transferFrom(amount)` increases the contract balance by exactly `amount` and `transfer(amount)` decreases it by exactly `amount`. This assumption is baked into core accounting paths such as `buy()/buyFor()` (via `purchaseTokens()`), `donatePool()`, `sell()`, and `withdraw()`: internal ledgers (e.g., minted share amounts, `totalDeposits`, `dividendBalance_`, and dividend distribution via `profitPerShare_`) are updated using the input `amount` rather than the actual number of tokens received/sent.\n\nIf `token` is fee-on-transfer/taxed/deflationary or otherwise non-standard (common on BSC), the contract will over-credit users on deposit (minting too many internal tokens and/or booking too much distributable value) and/or mis-account on withdrawals/sells. This desynchronizes internal \u201cshare/dividend\u201d accounting from real collateral held, enabling an attacker to create phantom value and extract real tokens that belong to other participants (draining the pool and/or causing insolvency), potentially even within a single transaction using large temporary liquidity.", "fix_description": "For every inbound transfer (`buyFor`, `buy`, `donatePool`), compute `received = balanceAfter - balanceBefore` and pass `received` into `purchaseTokens()` / pool accounting (or revert if `received != expected` to explicitly forbid taxed tokens). For outbound transfers (`withdraw`, `sell` payouts), similarly base accounting on actual sent amounts (or disallow fee-on-transfer tokens). Use `SafeERC20` and enforce post-conditions such as `token.balanceOf(address(this))` being sufficient before/after critical operations.", "focus_areas": ["asset_management", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:16:13.531549+00:00", "code_visible": false}}
{"id": "gangsterfinance", "name": "Gangsterfinance", "chain_id": 56, "block_number": 51782712, "target_contract": "0xe968D2E4ADc89609773571301aBeC3399D163c3b", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-06/Gangsterfinance_exp.sol", "defihacklabs_vuln_type": "Incorrect dividends", "exploit_file": "Gangsterfinance_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1750418375, "native_token_price_usd": 641.89, "tags": [], "lost_amount_usd": 16500.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "resolve() misaccounts burned shares as newly-withdrawable dividends via incorrect payoutsTo_ adjustment", "severity": "critical", "content": "The vault\u2019s dividend accounting is broken in resolve(), allowing a user to create withdrawable \u201cdividends\u201d that are not backed by their earned yield. When a user resolves (burns) shares, the function computes a 10% fee and a \u201ctaxed\u201d amount, then updates the user\u2019s dividend checkpoint (payoutsTo_) by subtracting both (a) the user\u2019s profitPerShare_ checkpoint for the burned shares and (b) an additional term equal to `_taxedTokens * magnitude`. This second term effectively credits the user with `_taxedTokens` of withdrawable dividends immediately after burning shares.\n\nBecause harvest() pays dividends from the contract\u2019s actual token balance (not from a segregated per-user principal balance), this accounting lets users withdraw tokens that can come from global pools (e.g., donated/drip balances or other users\u2019 deposits), violating the intended invariant that exiting should only return the user\u2019s own principal net fees plus legitimately accrued yield. This enables draining of tokens that were never attributable to the resolver\u2019s share of distributed profit.\n\nIn short: resolve() turns principal (or other vault-held funds) into instantly claimable dividends due to an erroneous payoutsTo_ update, making the system insolvent and drainable under normal token behavior (no reentrancy required).", "fix_description": "In resolve(), remove the `_taxedTokens * magnitude` term from the payoutsTo_ adjustment. Burning shares should only stop future dividend accrual by subtracting `profitPerShare_ * amount` from payoutsTo_. Handle principal separately: transfer `_taxedTokens` to the user (or credit a dedicated withdrawable-principal balance) rather than representing it as dividends. Add invariants/tests: deposit then immediate resolve must not increase harvestable dividends beyond already-distributed profit; donations/drip pool must only be claimable proportionally over time.", "focus_areas": ["business_logic", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:16:19.144895+00:00", "code_visible": false}}
{"id": "resupply_fi", "name": "Resupply Fi", "chain_id": 1, "block_number": 22785460, "target_contract": "0x6e90c85a495d54c6d7E1f3400FEF1f6e59f86bd6", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-06/ResupplyFi_exp.sol", "defihacklabs_vuln_type": "Token - pair manipulate", "exploit_file": "ResupplyFi_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1750902827, "native_token_price_usd": 2417.5, "tags": [], "lost_amount_usd": 9600000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Collateral valuation trusts manipulable ERC4626/share-token spot price without anti-manipulation guards", "severity": "critical", "content": "The protocol allows ERC4626-like vault share tokens (e.g., sCRVUSD) to be added/used as collateral and relies on an oracle/valuation path that can be moved materially within a single transaction. The borrow/LTV checks effectively treat the share token\u2019s instantaneous price/exchange rate as authoritative collateral value, without enforcing manipulation resistance (e.g., TWAP/medianization), staleness bounds, minimum-liquidity constraints, or a delay between deposit and borrowing. For vault shares in particular, share price can be distorted by state changes in the underlying vault (donations, controller interactions, tiny mints at an unfavorable rate, etc.) such that a very small share amount is briefly valued at an outsized asset amount by the protocol\u2019s pricing logic. Because this value feeds directly into solvency and borrow-limit enforcement, an attacker can mint/deposit a negligible amount of shares when the valuation is skewed and immediately borrow a disproportionate amount of the protocol\u2019s debt asset, creating bad debt and draining liquidity. The core flaw is treating a manipulable share-token \u201cprice\u201d as a secure oracle for collateral accounting.\n", "fix_description": "For ERC4626/share collateral, value collateral by intrinsic assets: compute `assets = IERC4626(collateral).convertToAssets(shares)` and multiply by a robust oracle price of the underlying asset (not the share token). Add oracle hardening (TWAP/median + staleness/heartbeat checks) and per-collateral anti-manipulation constraints (minimum deposit size, max per-block price deviation, and/or a borrow cooldown/block-delay after depositing a collateral type). Restrict supported collateral to assets with manipulation-resistant pricing and sufficient liquidity.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:16:33.755358+00:00", "code_visible": false}}
{"id": "fpc", "name": "Fpc", "chain_id": 56, "block_number": 52624700, "target_contract": "0xB192D4A737430AA61CEA4Ce9bFb6432f7D42592F", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-07/FPC_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "FPC_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1751466318, "native_token_price_usd": 660.07, "tags": [], "lost_amount_usd": 4700000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Token transfer hook moves assets out of the AMM pair (direct pair-balance mutation + sync) during sells", "severity": "critical", "content": "The sell path in `_update(from,to,value)` performs side effects that directly mutate the UniswapV2/PancakeV2 pair\u2019s token balance outside the pair\u2019s `swap/mint/burn` flow. When `to == usdtPool` (sell) and the transfer is not classified as liquidity add, the contract computes `burnPoolAmount = value * 65%` and calls `burnLpToken(burnPoolAmount)`. `burnLpToken()` executes `super._update(usdtPool, treasuryAddress, ...)` and `super._update(usdtPool, rewardPoolAddress, ...)`, forcibly transferring the token out of the pair contract\u2019s balance, then calls `IUniswapV2Pair(usdtPool).sync()`.\n\nThis is not a standard fee-on-transfer mechanism (which debits the sender). Instead it debits the pool itself, meaning any user sell can reduce pool reserves unilaterally. UniswapV2 pairs assume reserves/balances only change as part of their own swap/mint/burn logic and rely on invariant enforcement based on those flows. External debits of the pair\u2019s balance during a swap can desynchronize expected amounts, break invariant assumptions, and allow trades at incorrect prices, enabling loss of the counter-asset and draining liquidity. Even if intended tokenomics, it is effectively a pool-draining mechanism executable by any seller and creates a severe economic attack surface against LPs and traders.", "fix_description": "Remove any logic that transfers tokens out of `usdtPool` from within ERC20 transfer hooks. Specifically: delete/disable `burnLpToken()` calls from `_update()` sell path and remove `super._update(usdtPool, ...)` transfers and `pair.sync()` from token transfer logic. If treasury/reward funding is required, collect fees from the seller (or to `address(this)`) and process them via explicit router interactions (swap/add/remove liquidity) in controlled functions that do not directly mutate pair balances.", "focus_areas": ["economic_attacks", "business_logic"], "auditable": true}, {"title": "Liquidity add/remove detection based on pair balances vs reserves is manipulable and changes sell/buy enforcement paths", "severity": "high", "content": "The contract attempts to detect liquidity adds/removals in `_isLiquidity(from,to)` by comparing the pair\u2019s current token balances (`IERC20(token).balanceOf(pair)`) against `pair.getReserves()`. This heuristic is unreliable because (1) reserves are only updated at specific points (`swap/mint/burn/sync`), (2) swaps temporarily change balances before reserves update, and (3) anyone can transfer either token to the pair at arbitrary times (\u201cdonations\u201d), making balance-reserve deltas attacker-controlled.\n\nThis matters because `_update()` changes core behavior based on the `(isAdd, isDel)` classification. In particular, the sell branch applies fees and invokes the pair-mutating `burnLpToken()` only when `!isAdd`. If an attacker can force the heuristic to return `isAdd=true` during a normal sell (or affect `isDel` during buys), they can bypass intended fee/limit paths and control when the most dangerous side effects execute. This increases exploitability and makes trading rules dependent on transient, manipulable pair state.\n\nRelying on balance-vs-reserve comparisons for liquidity detection is a known anti-pattern in taxed tokens and should not be used to branch security-critical transfer behavior.", "fix_description": "Remove `_isLiquidity()` and do not branch fee/burn/limit logic on reserve-vs-balance heuristics. Apply consistent rules for any transfer involving the pair. If liquidity operations require exemptions, implement explicit, narrowly-scoped whitelisting (e.g., trusted router-managed addresses) without using pair balance/reserve comparisons.", "focus_areas": ["execution_flow", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:17:19.774002+00:00", "code_visible": true}}
{"id": "multicall_with_eth", "name": "Multicall With Eth", "chain_id": 56, "block_number": 55371342, "target_contract": "0x3DA0F00d5c4E544924bC7282E18497C4A4c92046", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-07/MulticallWithETH_exp.sol", "defihacklabs_vuln_type": "business logic flaw", "exploit_file": "MulticallWithETH_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1753526471, "native_token_price_usd": 793.71, "tags": ["requires_external_state"], "lost_amount_usd": 10000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "aggregate() allows unrestricted arbitrary external calls using this contract as msg.sender", "severity": "critical", "content": "The contract exposes a generic executor via aggregate() that lets any caller provide an unbounded list of (target, callData, value) entries which are executed using low-level call. There is no access control, no allowlist of permissible targets/selectors, and no restriction to read-only execution. Consequently, aggregate() effectively turns the contract into a public, permissionless \u201ccall forwarder\u201d that can invoke arbitrary functions on arbitrary contracts with this contract\u2019s authority (msg.sender becomes this contract).\n\nThis becomes critical whenever the contract (a) holds ETH/tokens, or (b) has been granted ERC20 allowances/approvals by any address, or (c) is whitelisted/privileged by downstream protocols that rely on msg.sender checks. In those cases, any external user can trigger token movements (e.g., transferFrom against any account that approved this contract), approvals, or privileged downstream actions, causing direct loss of third-party funds or abuse of integrations. The issue is not related to reentrancy or arithmetic; it is a missing authorization boundary around a powerful arbitrary-call primitive.", "fix_description": "Restrict aggregate() to authorized callers (e.g., onlyOwner / role-based access), and/or enforce an allowlist of callable targets and selectors. If the intended use is batching reads, replace call with staticcall and remove any ETH/value forwarding. If batching writes is required, require explicit per-user authorization (e.g., signed meta-transactions) rather than allowing arbitrary public execution.", "focus_areas": ["access_control", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:16:20.000321+00:00", "code_visible": true}}
{"id": "stepp2p", "name": "Stepp2P", "chain_id": 56, "block_number": 54653986, "target_contract": "0x99855380E5f48Db0a6BABeAe312B80885a816DCe", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-07/Stepp2p_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "Stepp2p_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1752988396, "native_token_price_usd": 757.12, "tags": [], "lost_amount_usd": 43000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Sale cancellation does not clear remaining balance and modifySaleOrder lacks active-state check", "severity": "critical", "content": "The sale lifecycle state is not enforced consistently across functions that transfer escrowed USDT back to the seller. In `cancelSaleOrder(uint256)`, the contract transfers `sale.remaining` to the seller and only flips `sale.active = false`, but it does not clear or otherwise invalidate `sale.remaining`. Separately, `modifySaleOrder(uint256,uint256,bool)` (when decreasing the order, `isPositive == false`) only checks `sales[_saleId].remaining >= _modifyAmount` and does not require the sale to be active. As a result, a seller can cancel a sale (receiving the full `remaining` amount), then call `modifySaleOrder` on the same sale to decrease it again and receive another transfer based on the unchanged `remaining` value. Because payouts are funded from the contract\u2019s pooled USDT balance, this breaks escrow invariants and enables draining funds belonging to other users\u2019 active sales (TVL theft) while the sale is already inactive/canceled.\n\nThis is a pure state-accounting bug: multiple code paths can pay out the same escrowed balance without a single terminal \u201csettled\u201d state, and without zeroing balances before external transfers.", "fix_description": "Enforce a single terminal state and clear balances on cancellation/withdrawal. Minimum: in `cancelSaleOrder`, set `sale.remaining = 0` (and ideally `sale.totalAmount = 0`) before any transfer (checks-effects-interactions). Additionally, add `require(sales[_saleId].active, \"Sale inactive\");` to `modifySaleOrder` (and any other mutating/withdrawing path). Consider adding a `settled`/`canceled` flag and ensure only one function can ever transfer the sale\u2019s remaining escrow.", "focus_areas": ["asset_management", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:17:06.270436+00:00", "code_visible": false}}
{"id": "grizzifi", "name": "Grizzifi", "chain_id": 56, "block_number": 57478533, "target_contract": "0x21ab8943380B752306aBF4D49C203B011A89266B", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-08/Grizzifi_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "Grizzifi_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1755107000, "native_token_price_usd": 848.57, "tags": [], "lost_amount_usd": 61000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Milestone qualification uses lifetime `totalInvested` instead of active stake, allowing permanent eligibility after withdrawal", "severity": "high", "content": "The milestone/team counting logic treats an upline as \u201cqualified\u201d based on `users[upline].totalInvested >= minInvestForMilestone` inside `_incrementUplineTeamCount()`. However, `totalInvested` is a lifetime accumulator that only increases on deposits and is never reduced when capital is withdrawn (and does not reflect whether the user currently has any active investment).\n\nAs a result, a user can qualify once by making a minimal deposit meeting `minInvestForMilestone`, then later withdraw their capital while remaining permanently eligible for milestone/team counting. Because `_incrementUplineTeamCount()` is called on downstream qualifying deposits, an attacker can repeatedly trigger team-count increments and milestone progression for an upline set that no longer has meaningful capital at risk.\n\nThis breaks the intended economic invariant that milestone rewards correspond to an upline with active stake and an organically growing team. It enables systematic inflation of `teamsCount`/`milestoneIndex` and accrual of `milestoneReward` (claimable via `collectRefBonus()`), allowing extraction of milestone bonuses disproportionate to real TVL and potentially draining contract funds.\n\n", "fix_description": "Replace the `totalInvested` gate with an \u201cactive invested\u201d measure that decreases on capital withdrawal.\n\n- Add `uint256 activeInvested;` to `User`.\n- In `harvestHoney()`: increment `users[msg.sender].activeInvested += amountCredited;`.\n- In `retrieveHoneyPot()` (when an investment\u2019s capital is withdrawn/marked withdrawn): decrement `users[msg.sender].activeInvested -= investment.amount;`.\n- In `_incrementUplineTeamCount()`: change eligibility from `users[upline].totalInvested >= minInvestForMilestone` to `users[upline].activeInvested >= minInvestForMilestone`.\n\nOptionally add a minimum active-duration requirement or only count downlines with active (non-withdrawn) investments toward milestones.", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:16:55.507412+00:00", "code_visible": true}}
{"id": "hexotic", "name": "Hexotic", "chain_id": 1, "block_number": 23260640, "target_contract": "0x204B937FEaEc333E9e6d72D35f1D131f187ECeA1", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-08/Hexotic_exp.sol", "defihacklabs_vuln_type": "Incorrect Input Validation", "exploit_file": "Hexotic_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1756637423, "native_token_price_usd": 4392.43, "tags": ["scraper_comment_mismatch"], "lost_amount_usd": 500.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Offer creation bug: offer ID is never propagated to caller due to pass-by-value parameter in newOffer()", "severity": "critical", "content": "The offer-creation flow incorrectly attempts to return a newly generated offer id by passing an uninitialized local variable `id` into `newOffer(id, ...)` and then assigning to `id` inside `newOffer()`.\n\nIn Solidity, function parameters are passed by value; therefore, assignments to the parameter `id` inside `newOffer()` do not update the caller\u2019s local `id`. As a result, `offerETH()`/`offerHEX()`/`make()` return `0` (default value) instead of the actual id generated by `_next_id()`. Additionally, events emitted by the offer-creation functions log `bytes32(id)` which will also be `0`.\n\nThis breaks the contract\u2019s core business logic: external systems (UIs, indexers, bots, users) that rely on the returned id or event id can be tricked into referencing the wrong offer, while the contract state may contain valid offers under different ids. Any workflow that uses the emitted/returned id as the canonical identifier can misbind order intent to an unrelated existing offer, enabling unintended fills/cancels and value loss.\n\nThis is a protocol-integrity failure in the primary execution path and should be treated as exploitable.\n", "fix_description": "Refactor `newOffer()` to return the generated id (or set it in the caller without pass-by-value). Then use that returned id for storage, return value, and emitted events. Example:\n\n- Change signature to `function newOffer(uint pay_amt, uint buy_amt, uint escrowType) internal returns (uint id)`\n- Inside: `id = _next_id(); offers[id] = ...;`\n- In `offerETH/offerHEX/make`: `id = newOffer(pay_amt, buy_amt, escrowType); emit LogMake(bytes32(id), ...); return id;`", "focus_areas": ["business_logic", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:17:00.183332+00:00", "code_visible": true}}
{"id": "multicall_with_xera", "name": "Multicall With Xera", "chain_id": 56, "block_number": 58269337, "target_contract": "0x93E99aE6692b07A36E7693f4ae684c266633b67d", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-08/MulticallWithXera_exp.sol", "defihacklabs_vuln_type": "business logic flaw", "exploit_file": "MulticallWithXera_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1755700170, "native_token_price_usd": 869.43, "tags": ["requires_external_state", "scraper_comment_mismatch"], "lost_amount_usd": 17000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Unprotected one-time initializer lets anyone set reward token and router/pair", "severity": "critical", "content": "The contract is not deployed behind a proxy, yet it relies on an external `initializer` function (`afterConstructor`) to perform critical post-deployment configuration. The `initializer` modifier only prevents multiple executions; it does not restrict who can perform the first initialization. Because `afterConstructor(address _rewardToken, address _router)` is `external` and lacks access control (e.g., `onlyOwner`), any address can call it first and permanently set `rewardToken` and `routerV2`.\n\nThis is especially dangerous because `afterConstructor` calls `_updateRouterV2(_router)`, which (a) creates/sets the AMM pair via the router\u2019s factory and (b) grants the router an effectively infinite allowance from the token contract. If an attacker initializes with an untrusted router or unexpected reward token, they can undermine the project\u2019s intended DEX wiring, manipulate or break swap/dividend flows, and potentially abuse the token contract\u2019s approvals and pair configuration. Even if a malicious router is not used, simply front-running initialization breaks the trust assumption that only the deployer/owner configures core protocol dependencies after deployment.", "fix_description": "Restrict `afterConstructor` to the contract owner (and ideally move this logic into the constructor for non-upgradeable deployments). For example:\n\n```solidity\nfunction afterConstructor(address _rewardToken, address _router)\n    external\n    onlyOwner\n    initializer\n{\n    _setRewardToken(_rewardToken);\n    _updateRouterV2(_router);\n}\n```\n\nOptionally validate `_router` is a contract and/or an approved router address before accepting it.", "focus_areas": ["access_control", "upgradeable_contracts"], "auditable": true}, {"title": "ERC20 transferFrom enables third-party drains when users approve generic executors (no spender restrictions)", "severity": "high", "content": "The token uses standard ERC20 allowance semantics: `transferFrom(from, to, amount)` authorizes transfers solely based on the allowance `from` has granted to `msg.sender`. This is expected ERC20 behavior, but it becomes a systemic risk for privileged/treasury wallets if they ever approve \u201cgeneric execution\u201d contracts (e.g., multicall/aggregator executors) rather than a narrowly scoped spender.\n\nBecause generic executors are designed to perform arbitrary external calls on behalf of the caller, any third party can often invoke them to call `token.transferFrom(victim, recipient, amount)` as long as the victim previously approved that executor. The token does not implement any additional guardrails (spender allowlists, restricted transferFrom, or specialized treasury custody patterns) to reduce the blast radius of such approvals. As a result, accidental or operationally convenient approvals to common executors can be turned into immediate, permissionless drains of the approving wallet\u2019s token balance.\n\nWhile this is not a \u201cbug\u201d in the ERC20 logic per se, it is a realistic and high-impact threat model for admin/treasury accounts and should be addressed via governance/operational controls and (optionally) contract-side protections if acceptable for the project\u2019s composability requirements.", "fix_description": "Operational: do not approve generic executors from treasury/owner wallets; use minimal allowances and revoke after use.\n\nContract-side (optional, reduces composability): add spender restrictions in `_spendAllowance` (allowlist approved spenders), or keep treasury funds in a dedicated custody contract (e.g., multisig vault) that does not grant broad ERC20 approvals and requires explicit admin authorization for transfers.", "focus_areas": ["asset_management", "compliance_governance"], "auditable": false}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:17:28.487543+00:00", "code_visible": true}}
{"id": "pdz", "name": "Pdz", "chain_id": 56, "block_number": 57744490, "target_contract": "0x664201579057f50D23820d20558f4b61bd80BDda", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-08/PDZ_exp.sol", "defihacklabs_vuln_type": "Price Manipulation", "exploit_file": "PDZ_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1755306490, "native_token_price_usd": 839.08, "tags": [], "lost_amount_usd": 2768.964, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "burnToHolder() derives reward value from AMM spot quote (getAmountsOut) without manipulation resistance", "severity": "critical", "content": "In burnToHolder(), the contract calculates the BNB-denominated reward amount (`deserved`) via `uniswapRouter.getAmountsOut(amount, path)` using the PDZ/WBNB pool as a pricing source. `getAmountsOut` is not an oracle; it returns a spot quote computed from the pool\u2019s current reserves. Because reserves can be moved within the same transaction, this value is inherently manipulable and should not be treated as an authoritative measure of value for issuing rewards. The computed `deserved` is subsequently used by `burnFeeRewards()` to credit/mint reward entitlement (and transfer TB_BUILD from the contract) while recording `burnAmount`, effectively allowing users to create an outsized claim on the contract\u2019s assets when the spot quote is distorted. This breaks the intended economic model: reward issuance becomes dependent on an instantaneous, attacker-influenceable DEX state rather than a stable, manipulation-resistant price, enabling extraction of the contract\u2019s BNB-backed rewards and draining of funds.\n\nAny mechanism that pays out or credits value based on AMM spot reserves must assume adversarial reserve changes and incorporate price-oracle protections.", "fix_description": "Remove use of `uniswapRouter.getAmountsOut(...)` as the reward oracle. Replace with a manipulation-resistant price source, e.g. (1) a UniswapV2-style TWAP using cumulative prices over a sufficiently long window, or (2) a trusted external oracle (e.g., Chainlink PDZ/BNB). Additionally, enforce sanity bounds (max reward per burn, min liquidity, deviation checks vs. TWAP/anchor) so a single call cannot mint/credit excessive rewards.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:17:40.367820+00:00", "code_visible": false}}
{"id": "size_credit", "name": "Size Credit", "chain_id": 1, "block_number": 23145763, "target_contract": "0xF4a21Ac7e51d17A0e1C8B59f7a98bb7A97806f14", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-08/SizeCredit_exp.sol", "defihacklabs_vuln_type": "business logic flaw", "exploit_file": "SizeCredit_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1755252815, "native_token_price_usd": 4443.12, "tags": ["requires_external_state"], "lost_amount_usd": 19700.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "GenericRoute swap executes arbitrary external call with attacker-controlled target and calldata (no router/selector validation)", "severity": "critical", "content": "The swap execution path used by `leverageUpWithSwap(...)` for `SwapMethod.GenericRoute` performs a low-level external call using bytes provided in `SwapParams.data` without sufficiently constraining what can be called. Specifically, the contract allows the caller to effectively choose (1) the call target address and (2) the calldata, and then executes that call in the context of this contract.\n\nBecause the call originates from the protocol contract, any ERC20 approvals previously granted to the protocol (by any user) can be abused: an attacker can supply calldata that invokes arbitrary ERC20 methods (e.g., `transferFrom`, `approve`) on arbitrary token contracts, draining user funds that have approved the protocol contract. Additionally, if the GenericRoute decoding relies on user-controlled dynamic offsets/lengths, malformed calldata can redirect the decoded fields and further weaken assumptions about what is being called.\n\nImpact: complete loss of user funds approved to the contract, and potentially other unintended external effects, since the contract is turned into a generic call proxy rather than a constrained swap executor.", "fix_description": "Remove arbitrary-call behavior from GenericRoute. Enforce strict validation by: (1) whitelisting allowed router/aggregator targets and rejecting any other `target`; (2) allowlisting permitted function selectors per router (verify `bytes4(calldata[0:4])`); (3) decoding `SwapParams.data` via `abi.decode` into a strict struct (no manual offset parsing), with explicit bounds checks; and (4) verifying `tokenIn`/`tokenOut` and enforcing the swap recipient is the protocol (not an arbitrary receiver).", "focus_areas": ["input_validation", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:17:10.762601+00:00", "code_visible": false}}
{"id": "98_token", "name": "98 Token", "chain_id": 56, "block_number": 45462897, "target_contract": "0xB040D88e61EA79a1289507d56938a6AD9955349C", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/98Token_exp.sol", "defihacklabs_vuln_type": "Unprotected public function", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1735969857, "native_token_price_usd": 713.33, "tags": [], "lost_amount_usd": 28000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Public DEX router wrapper functions lack access control and allow arbitrary swap recipients", "severity": "critical", "content": "The contract exposes public wrapper functions around PancakeSwap router operations (notably `swapTokensForTokens(...)`, and related liquidity/quote helpers) without any access control or restriction on critical parameters. Because swaps are executed from the contract context, the router pulls tokens from `address(this)` using ERC20 allowances. The system design additionally grants the router large (effectively unlimited) allowances for core tokens (e.g., USDT and the project `Token`, and any token later set via `setToken()`), meaning any externally callable swap can spend the contract\u2019s balances of those approved tokens.\n\nCritically, the wrapper allows the caller to choose the `path`, `amountIn`, `amountOutMin`, and especially the `to` recipient address. As a result, any external account can instruct the contract to swap all contract-held balance of an approved token into another asset and direct the output to an arbitrary recipient. This turns the contract into a publicly callable \u201chot wallet\u201d with DEX spend authority: if the contract ever holds balances of an approved token (from liquidity operations, rewards, or accidental transfers), those assets can be converted and forwarded out without requiring any privileged role.", "fix_description": "Remove external/public router wrappers or make them `internal` and only callable from controlled protocol flows. If external calls are required, add strict access control (e.g., `onlyOwner`/role) and restrict swap recipients and paths:\n- `require(to == address(this) || to == trustedReceiver)`\n- validate `path` against an allowlist\n- enforce non-zero `amountOutMin` based on a quote and slippage tolerance.\nAlso replace unlimited approvals with per-operation approvals (approve exact amount, then reset to 0) for core assets.", "focus_areas": ["access_control", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:17:35.868096+00:00", "code_visible": false}}
{"id": "idols_nft", "name": "Idols Nft", "chain_id": 1, "block_number": 21624138, "target_contract": "0x439cac149B935AE1D726569800972E1669d17094", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/IdolsNFT_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1736874695, "native_token_price_usd": 3224.35, "tags": [], "lost_amount_usd": 324000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "ERC721 transfer hook triggers reward claiming twice without guarding self-transfers", "severity": "critical", "content": "IdolMain opportunistically distributes stETH rewards during ERC721 transfers by calling `_claimEthRewards(from)` and `_claimEthRewards(to)` inside `_beforeTokenTransfer`. However, the hook does not special-case self-transfers (`from == to`). In that case, the hook can execute the \u201cfrom\u201d reward-claim path and then immediately execute the \u201cto\u201d path for the same address again within a single transfer.\n\nBecause `_beforeTokenTransfer` is invoked before ERC721Enumerable updates balances, `balanceOf(to)` still reflects the pre-transfer state during a self-transfer, so the code can enter the branch intended for existing holders (`if (balanceOf(to) > 0)`). This makes the reward snapshot and `allocatedStethRewards` accounting vulnerable to being updated and paid multiple times without any real change in ownership.\n\nImpact: a user can repeatedly call `safeTransferFrom(self, self, tokenId)` to trigger repeated reward payouts and drain stETH allocated for rewards from the contract, while maintaining the same NFT ownership. This is a direct loss of funds from the reward pool and breaks core reward distribution invariants.\n", "fix_description": "In `_beforeTokenTransfer`, add an explicit guard for self-transfers so that at most one reward-claim path runs:\n\n- `if (from == to) return;` (or skip the second claim), and ensure snapshots are updated exactly once per transfer.\n\nAdditionally, consider removing reward claiming from `_beforeTokenTransfer` entirely and moving it to an explicit user-initiated `claim()` function, or restructure transfer-time accounting to be invariant to ERC721 balance update ordering.", "focus_areas": ["business_logic", "asset_management"], "auditable": true}, {"title": "Contract interaction restrictions rely on Address.isContract, which is bypassable during contract construction", "severity": "medium", "content": "The `onlyAllowedContracts` restriction uses `Address.isContract(addr)` to distinguish EOAs from contracts and to enforce a blacklist/whitelist policy for transfers/approvals. This pattern is not reliable for access control because `extcodesize(address)` is zero during a contract\u2019s constructor, causing `Address.isContract` to return false even though the caller/recipient is a contract.\n\nAs a result, any security assumptions based on preventing contract-based interactions (e.g., blocking automated loops, bot activity, or contract wallets) can be bypassed by performing the restricted actions from within a constructor. This undermines the intended protection surface of `onlyAllowedContracts` and can materially increase exploitability of other logic bugs by enabling fully-automated contract execution even when contract-to-contract interactions are meant to be restricted.\n\nEven if currently configured permissively (e.g., `allowAllContracts == true`), the presence of this mechanism can create a false sense of safety and may be relied upon operationally later (e.g., toggling to restrictive mode during an incident), despite being bypassable.\n", "fix_description": "Do not use `Address.isContract` for access control. Remove or redesign `onlyAllowedContracts` restrictions:\n\n- If you need to restrict transfers, enforce intent-based permissions (explicit allowlists for operators/marketplaces, role-based controls, or signature-based approvals).\n- If a blacklist/allowlist is required, enforce it on `msg.sender`/operator addresses and assume contracts can call (including from constructors).", "focus_areas": ["access_control"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:18:06.752044+00:00", "code_visible": false}}
{"id": "j_pulsepot", "name": "J Pulsepot", "chain_id": 56, "block_number": 45640245, "target_contract": "0x384b9fb6E42dab87F3023D87ea1575499A69998E", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/JPulsepot_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1736501998, "native_token_price_usd": 692.81, "tags": [], "lost_amount_usd": 21500.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "swapProfitFees() is permissionless and relies on AMM spot quotes as a price oracle for LINK fee swaps and internal accounting", "severity": "critical", "content": "The contract\u2019s fee-conversion flow is exposed via a publicly callable `swapProfitFees()` that determines how much value to swap into LINK and how to update internal LINK-fee accounting using PancakeRouter spot quotations (`getAmountsIn/getAmountsOut`). AMM spot prices are not safe as an oracle because they can be manipulated within a single transaction and can deviate significantly from fair value during low-liquidity or transient reserve changes. Here, those quotes directly drive (1) how much casino liquidity/profit is spent to purchase LINK for VRF fees (`getTokenAmountForLink`) and (2) how much `linkSpent[tokenId]` is decremented (`_updateLinkConsumptionInfo` via `getLinkAmountForToken`).\n\nAdditionally, the actual swap is executed with `amountOutMin = 0`, meaning the contract accepts any execution price and will not revert on adverse price movement. This combination (permissionless trigger + manipulable pricing inputs + zero slippage checks + accounting updates based on quotes rather than realized amounts) allows an external caller to force economically unfavorable swaps and corrupt LINK-spend accounting, ultimately enabling draining or misappropriation of accumulated fee buckets and/or liquidity reserved for LINK purchases.\n\nBecause this logic is on a hot path that moves real assets and updates key accounting variables, it creates a direct economic drain vector.\n", "fix_description": "1) Restrict `swapProfitFees()` to a trusted role (e.g., `onlyOwner`/keeper) or redesign it as a controlled, rate-limited keeper action.\n2) Remove reliance on `router.getAmountsIn/getAmountsOut` for accounting decisions; use a TWAP (pair cumulative price) or Chainlink price feed for LINK/BNB and token/BNB.\n3) Add slippage protection: set `amountOutMin` based on oracle/TWAP with a configured max slippage, and revert if the swap output is below tolerance.\n4) Make `linkSpent` accounting depend on realized LINK amounts (actual LINK received/spent) rather than router quotes; decrement based on actual swap output and VRF payments in LINK units.", "focus_areas": ["oracle_manipulation", "access_control"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:17:47.982617+00:00", "code_visible": false}}
{"id": "lp_mine", "name": "Lp Mine", "chain_id": 56, "block_number": 45583892, "target_contract": "0x6BBeF6DF8db12667aE88519090984e4F871e5feb", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/LPMine_exp.sol", "defihacklabs_vuln_type": "Incorrect reward calculation", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1736332913, "native_token_price_usd": 695.87, "tags": [], "lost_amount_usd": 24000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Reward accrual uses manipulable AMM spot state (pair balances/router quotes) as a value oracle", "severity": "critical", "content": "Reward amounts are derived from the instantaneous state of a UniswapV2-style pool, which is not manipulation-resistant. In `getCanClaimed()` the contract estimates a user\u2019s LP \u201cvalue\u201d via `getRemoveTokens()`, which computes underlying amounts using `IERC20(token).balanceOf(pair) * lpAmount / totalSupply` (and similarly for USDT). These raw ERC20 balances at the pair address are not a safe oracle: they can be changed without minting/burning LP by transferring tokens directly to the pair (and may differ from reserves until a sync). In `getEachReward()`, this computed USDT value is then converted into reward token amounts using `router.getAmountsOut()`, which is also a spot quote based on current pool reserves and can be distorted within a single transaction.\n\nBecause `extractReward()` pays rewards directly from `rewardPool` based on this live, manipulable valuation, an attacker can temporarily skew the pool\u2019s apparent balances/price and claim outsized rewards, draining the reward pool without needing to maintain the manipulated state. The contract has no TWAP, no bounds checks, and no user-specific principal tracking to anchor reward calculations.\n", "fix_description": "Remove dependence on spot AMM state for reward valuation. Options:\n- Track user principal at deposit time (e.g., store deposited USDT-equivalent) and emit rewards from that fixed baseline.\n- If a price feed is required, use a manipulation-resistant oracle (e.g., Chainlink) or a Uniswap TWAP (cumulative price over a minimum window). \n- If you must use pool state, use `IUniswapV2Pair.getReserves()` (not `balanceOf(pair)`) with correct token ordering, and add TWAP/price-deviation guards before allowing claims.\nUpdate `getRemoveTokens()`/`getEachReward()` accordingly so claims cannot be influenced by same-block reserve/balance changes.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:18:32.172436+00:00", "code_visible": true}}
{"id": "roulette_pot_v2", "name": "Roulette Pot V2", "chain_id": 56, "block_number": 45668285, "target_contract": "0xf573748637E0576387289f1914627d716927F90f", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/RoulettePotV2_exp.sol", "defihacklabs_vuln_type": "Price Manipulation", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1736586122, "native_token_price_usd": 696.51, "tags": [], "lost_amount_usd": 28000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "swapProfitFees() is permissionless and executes AMM swaps using spot quotes and amountOutMin=0", "severity": "critical", "content": "The contract exposes swapProfitFees() as an unrestricted external function that any account can call at any time. This function computes how much token/BNB should be swapped to fund LINK subscription costs via PancakeRouter.getAmountsIn()/getAmountsOut() and then performs real swaps (token->BNB and BNB->LINK) with amountOutMin hardcoded to 0. AMM router quote functions are not manipulation-resistant; they reflect instantaneous pool reserves and can be moved significantly within a single block/transaction. Because swapProfitFees() both (a) uses these spot quotes for accounting (deducting from casino liquidity/profit) and (b) executes swaps with zero slippage protection, an external caller can force the protocol to trade at an arbitrarily unfavorable rate, realizing large value loss from protocol-held balances. The risk is amplified because the function can swap across multiple casinos in one call, and because it is callable by anyone, allowing adversaries/MEV to time execution when liquidity is thin or prices are transiently distorted. This enables direct economic drain of protocol funds via adverse execution rather than merely \u201cbad pricing.\u201d", "fix_description": "1) Add access control to swapProfitFees() (e.g., onlyOwner/onlyRole keeper) and optionally rate-limit calls.\n2) Replace getAmountsIn/getAmountsOut spot quotes used for LINK/token budgeting with a manipulation-resistant oracle (Chainlink price feed or AMM TWAP) and derive expected amounts from that oracle.\n3) Enforce slippage protections: compute amountOutMin from oracle/TWAP-based expectedOut with a configurable maxSlippageBps; never use 0.\n4) Prefer exact-output swaps for LINK funding (e.g., swapTokensForExactTokens / swapETHForExactTokens) to cap input and prevent input ballooning when price is manipulated.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:18:27.543321+00:00", "code_visible": true}}
{"id": "sorra_staking", "name": "Sorra Staking", "chain_id": 1, "block_number": 21450734, "target_contract": "0x5d16b8Ba2a9a4ECA6126635a6FFbF05b52727d50", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/sorraStaking.sol", "defihacklabs_vuln_type": "Incorrect reward calculation", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1734782291, "native_token_price_usd": 3337.38, "tags": ["requires_time_manipulation"], "lost_amount_usd": 41000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Rewards are not checkpointed, allowing already-paid rewards to remain claimable", "severity": "critical", "content": "The reward logic pays users based on a recomputation over their currently-recorded deposits without tracking what portion of those rewards has already been paid. Specifically, `getPendingRewards()`/`_calculateRewards()` sum rewards for each deposit whose vesting period has elapsed as `dep.amount * dep.rewardBps / 10000`. However, there is no per-deposit \u201cclaimed\u201d flag and no per-user reward debt/checkpoint to subtract rewards already distributed. Although `userRewardsDistributed` is incremented, it is never used to reduce future pending rewards.\n\nIn `withdraw()`, rewards are calculated and paid before/alongside reducing principal. The principal reduction in `_decreasePosition()` only subtracts the withdrawn amount from matured deposits, but it does not correspondingly mark the reward for the remaining matured principal as paid. Therefore, after deposits are vested, a user can call `withdraw()` repeatedly with small amounts and each call will continue to consider (nearly) the same matured principal as reward-eligible, leading to repeated reward payouts until contract liquidity is exhausted.\n\nImpact: deterministic draining of the contract\u2019s reward token balance and insolvency for other users.\n", "fix_description": "Add reward accounting so rewards are only paid once per eligible principal. Options:\n- Per-deposit claimed tracking: extend `Deposit` with `bool rewardClaimed` (or `uint256 rewardClaimedAmount`), sum only unclaimed matured deposits in `_calculateRewards()`, and mark relevant deposits as claimed when paying rewards.\n- Reward-debt model: maintain `rewardDebt[user]` and compute `pending = totalEarned(user) - rewardDebt[user]`; after payment update `rewardDebt[user]` consistently (ensure updates on deposit/withdraw so debt cannot be bypassed when principal changes).\nAlso ensure the reward checkpoint update happens in the same flow that transfers rewards.", "focus_areas": ["business_logic", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:18:14.370690+00:00", "code_visible": true}}
{"id": "hegic_options", "name": "Hegic Options", "chain_id": 1, "block_number": 21912408, "target_contract": "0x7094E706E75E13D1E0ea237f71A7C4511e9d270B", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-02/HegicOptions_exp.sol", "defihacklabs_vuln_type": "Business Logic Flaw", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1740354515, "native_token_price_usd": 2819.92, "tags": [], "lost_amount_usd": 80000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "withdrawWithoutHedge does not invalidate tranche claims after withdrawal (missing state/accounting update)", "severity": "critical", "content": "The pool\u2019s `withdrawWithoutHedge(uint256 trancheID)` implementation allows a tranche position to be withdrawn more than once because it does not permanently invalidate the tranche\u2019s claim on liquidity after paying out. A tranche is intended to represent a single-use claim (defined by stored fields such as `share`/`amount` and a lifecycle state). However, the function computes a positive withdrawal amount from the tranche\u2019s stored data and transfers underlying assets, without first marking the tranche as withdrawn/closed and zeroing (or burning) the claim. As a result, subsequent calls using the same `trancheID` continue to succeed and pay out again, since the tranche remains in a withdrawable state with non-zero accounting values. This is a checks-effects-interactions violation and a core asset-accounting flaw: the contract performs the \u201cinteraction\u201d (or makes the claim realizable) without applying the \u201ceffects\u201d that prevent re-use. Impact is total loss of pool funds, as any holder (or approved operator) of a tranche token/ID can repeatedly withdraw until the pool is drained. This issue does not require reentrancy; repeated direct calls are sufficient.", "fix_description": "In `withdrawWithoutHedge`, enforce single-use withdrawal by updating tranche storage BEFORE transferring funds: require tranche is in an `Open`/withdrawable state; compute payout; set `tranche.state = Closed` and zero out `tranche.share`/`tranche.amount` (or burn the tranche NFT / delete tranche storage); update any global totals accordingly; then transfer tokens. Add a regression test asserting a second call for the same `trancheID` reverts or returns 0. Optionally add `nonReentrant` for defense-in-depth.", "focus_areas": ["asset_management", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:18:28.663065+00:00", "code_visible": false}}
{"id": "bbx_token", "name": "Bbx Token", "chain_id": 56, "block_number": 47626456, "target_contract": "0x67Ca347e7B9387af4E81c36cCA4eAF080dcB33E9", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/BBXToken_exp.sol", "defihacklabs_vuln_type": "Price Manipulation", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1742461047, "native_token_price_usd": 630.24, "tags": [], "lost_amount_usd": 11902.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "AMM pair reserve burn + sync is executed inside _transfer and is publicly triggerable without updating lastBurnTime", "severity": "critical", "content": "The token\u2019s `_transfer` contains an \u201cLP burn\u201d routine that directly removes tokens from the AMM pair address (`liquidityPool`) and then calls `IPancakePari(liquidityPool).sync()` when a timestamp condition is met. Because this logic is executed in the ERC20 transfer hook, it is callable by any external user simply by initiating a token transfer (including trivial transfers), i.e., it is not restricted to trusted actors or to actual buy/sell flows. Critically, the contract does not update `lastBurnTime` when a burn occurs, so once `block.timestamp >= lastBurnTime + lastBurnGapTime` becomes true, the burn will execute on every subsequent transfer, continuously modifying the pair\u2019s balances.\n\nThis design violates AMM assumptions by mutating pool reserves outside normal swap/liquidity mechanics. Burning tokens from the pair without removing the paired asset changes the reserve ratio and spot price, enabling deterministic price/reserve manipulation and allowing attackers to extract value from traders/LPs. It can also repeatedly deplete the pair\u2019s token balance and potentially break transfers once the routine starts reverting due to insufficient pair balance or unexpected pair behavior.", "fix_description": "Remove the direct `super._transfer(liquidityPool, dead, burnNum)` and `pair.sync()` from `_transfer`. If an LP burn mechanism is required, execute it via a separate, access-controlled function (keeper/onlyOwner/timelock) and use AMM-safe mechanics (e.g., accumulate fees in-contract and swap/burn without forcing reserve changes). At minimum, update `lastBurnTime` when a burn occurs and prevent zero/trivial transfers from triggering it:\n```solidity\nif (block.timestamp >= lastBurnTime + lastBurnGapTime) {\n    lastBurnTime = block.timestamp;\n    ...\n}\n```", "focus_areas": ["economic_attacks", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:18:27.817737+00:00", "code_visible": true}}
{"id": "dcf_token", "name": "Dcf Token", "chain_id": 56, "block_number": 44290969, "target_contract": "0xA7e92345ddF541Aa5CF60feE2a0e721C50Ca1adb", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/DCFToken_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "DCFToken_exp.sol", "evm_version": "shanghai", "exploit_timestamp": 1732453673, "native_token_price_usd": 660.45, "tags": [], "lost_amount_usd": 442000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Token transfer logic burns tokens directly from the AMM pair balance and forces reserve updates via sync()", "severity": "critical", "content": "The token implements special logic in `_transfer` when `to == pairAddress` (i.e., transfers to the UniswapV2/PancakeSwap pair during sells). In this branch, the contract computes a `deadAmount` and calls `burnPair(deadAmount)`. `burnPair()` executes `_burn(pairAddress, _deadAmount)` and then calls `IUniswapV2Pair(pairAddress).sync()`.\n\nThis is fundamentally unsafe because it modifies the AMM pair\u2019s ERC20 token balance/reserves outside of the pair\u2019s swap/mint/burn mechanics. Burning tokens from `pairAddress` removes one side of liquidity without paying the corresponding asset, and `sync()` forces the pair to accept these manipulated balances as the new reserves. This breaks the implicit invariant assumptions used by AMMs and allows the pool price/reserves to be shifted \u201cfor free\u201d by anyone who can trigger a transfer to the pair. As a result, an attacker can manipulate the pool price and extract the paired asset from the AMM, causing direct loss of funds from LPs and protocol users.\n\nAny design that directly changes a UniswapV2 pair\u2019s balances (especially paired with `sync()`) in a token transfer hook should be considered exploitable.", "fix_description": "Remove the pair-burning mechanism entirely: delete `burnPair()` and the call to it from `_transfer`. If deflation is required, burn from the transferred amount (sender-side) or from fees held by the token contract itself; never burn tokens from `pairAddress` and never call `sync()` as part of transfer logic. If reducing liquidity is intended, do so only by explicitly removing liquidity (burning LP tokens) under strict governance controls.", "focus_areas": ["economic_attacks", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:19:03.629124+00:00", "code_visible": false}}
{"id": "one_inch_fusion_v1_settlement_hack", "name": "One Inch Fusion V1 Settlement Hack", "chain_id": 1, "block_number": 21982110, "target_contract": "0xA88800CD213dA5Ae406ce248380802BD53b47647", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/OneInchFusionV1SettlementHack.sol_exp.sol", "defihacklabs_vuln_type": "Arbitrary Yul Calldata", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1741194911, "native_token_price_usd": 2241.7, "tags": [], "lost_amount_usd": 5000000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Unsafe manual ABI parsing/patching of dynamic bytes allows out-of-bounds reads/writes and arithmetic overflow", "severity": "critical", "content": "Settlement._settleOrder(bytes,address,uint256,bytes) treats the user-supplied `data` blob as if it were well-formed ABI-encoded calldata for `IOrderMixin.fillOrderTo`, then uses Yul to manually locate and modify the dynamic `interaction` field (reading its offset and length directly from `data`). Because `settleOrders(bytes)` accepts arbitrary calldata and the code does not ABI-decode/validate the structure, the values loaded for `interaction` offset/length are fully attacker-controlled.\n\nThe assembly block then (1) patches `interaction.length` in the copied buffer and (2) computes an append pointer using `interactionOffset + interactionLength`, without verifying that offsets/lengths are within `data.length` or that additions cannot overflow. This enables out-of-bounds reads and memory writes into attacker-chosen positions within the buffer that will later be used as calldata for the `limitOrderProtocol.fillOrderTo` call. Corrupting the interaction payload and/or adjacent fields breaks the assumption that the downstream callback (`fillOrderInteraction` / `DynamicSuffix.decodeSuffix`) is decoding authentic, well-formed bytes, potentially allowing arbitrary resolver/fee parameters and unintended token approvals/transfers during settlement.\n", "fix_description": "Do not mutate a raw calldata blob using untrusted dynamic offsets. Prefer: ABI-decode `data` into typed parameters and re-encode using `abi.encodeWithSelector(fillOrderTo.selector, ...)` with `bytes.concat(interaction, suffix)`. If assembly must remain, add strict bounds and overflow checks before any load/store:\n- ensure `interactionLengthOffset + 0x20 <= data.length`\n- ensure `interactionOffset + 0x20 <= data.length` and `interactionOffset + interactionLength <= data.length`\n- revert on overflow for `interactionLength + suffixLength` and for pointer computations\n- reject unreasonable `interactionLength` values.", "focus_areas": ["input_validation", "arithmetic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:18:43.396579+00:00", "code_visible": false}}
{"id": "yzi_ai_token", "name": "Yzi Ai Token", "chain_id": 56, "block_number": 47838544, "target_contract": "0x7fDfF64Bf87bad52e6430BDa30239bD182389Ee3", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/YziAIToken_exp.sol", "defihacklabs_vuln_type": "Rug Pull", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1743097389, "native_token_price_usd": 637.4, "tags": [], "lost_amount_usd": 239400.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "ERC20 transferFrom contains a privileged magic-value branch that mints and swaps tokens", "severity": "critical", "content": "The token overrides the standard ERC20 `transferFrom` flow and embeds a special-case branch that triggers when `msg.sender == manager` and `amount == 1199002345`. In this branch, the contract executes highly privileged actions unrelated to allowance-based transfers, including minting a very large quantity of new tokens to itself, granting the DEX router a large approval, and performing a router swap from the token into ETH/BNB with proceeds sent to `manager`. The swap size is derived from `balanceOf(to)` (the caller-controlled `to` parameter), meaning the manager can choose a `to` address with a large token balance (e.g., an AMM pair) and force a large dump of (freshly minted) tokens into the pool. This violates ERC20 expectations (transferFrom should only move `amount` from `from` to `to` subject to allowance) and creates an undisclosed backdoor that enables arbitrary supply inflation and extraction of pool reserves. Because the trigger is a hidden sentinel `amount` value and is gated only by a single privileged address, it represents an immediate and catastrophic asset-loss risk for any on-chain liquidity.\n", "fix_description": "Remove the entire `if (msg.sender == manager && amount == 1199002345) { ... }` block so `transferFrom` strictly enforces allowances and only transfers `amount`. If administrative minting/swapping is required, implement separate explicit `onlyOwner/onlyRole` functions with clear parameters, hard caps, events, and (ideally) timelocks; never couple privileged behavior to ERC20 transfer functions or to magic trigger values.", "focus_areas": ["access_control", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:18:30.325319+00:00", "code_visible": false}}
{"id": "w_key_dao", "name": "W Key Dao", "chain_id": 56, "block_number": 47469059, "target_contract": "0xD511096a73292A7419a94354d4C1C73e8a3CD851", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/wKeyDAO_exp.sol", "defihacklabs_vuln_type": "unprotected function", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1741988827, "native_token_price_usd": 587.88, "tags": [], "lost_amount_usd": 737000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Sale contract mints sold token from a mutable, untrusted token address", "severity": "critical", "content": "The contract treats `wkey` as the sold token, but `wkey` is only an address set in `initialize(...)` and can later be changed via `setWkey(address)`. In `buy()`, the contract unconditionally calls `IMintable(wkey).mint(address(this), immediateTokens)` and then transfers those newly minted tokens to the buyer. There are no guarantees that `wkey` is (a) the intended token, (b) non-mintable, (c) capped, or (d) that minting is properly access-controlled. This creates a trust-boundary failure: purchase logic assumes minting is a safe internal inventory mechanism, but it actually depends entirely on an external token contract\u2019s mint authorization and behavior.\n\nIf `wkey` is (or can become) a token that allows this contract to mint freely (by design, misconfiguration, upgrade, or admin change), then each call to `buy()` becomes a public \u201cmint-on-demand\u201d endpoint that can inflate supply and distribute freshly minted tokens to buyers. This can be abused to acquire unbacked tokens and externalize losses onto any pools/venues where the token has value, and undermines any intended scarcity/availability constraints of the sale.\n\nBecause this mint is part of the core purchase flow, the issue enables direct value extraction and is not mitigated by typical per-user limits or sale availability accounting.", "fix_description": "Remove minting from `buy()` and sell from a pre-funded inventory: replace `IMintable(wkey).mint(...)` with `IERC20(wkey).transfer(msg.sender, immediateTokens)` and enforce `require(IERC20(wkey).balanceOf(address(this)) >= immediateTokens)`. Additionally: make `wkey` immutable (remove `setWkey`) or restrict changes via timelock/governance and whitelist only a vetted token address. If minting is required, hardcode a trusted minter and enforce strict mint caps tied to sale parameters.", "focus_areas": ["business_logic", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:19:10.620868+00:00", "code_visible": false}}
{"id": "irys_ai", "name": "Irys Ai", "chain_id": 56, "block_number": 49994891, "target_contract": "0x746727FC8212ED49510a2cB81ab0486Ee6954444", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-05/IRYSAI_exp.sol", "defihacklabs_vuln_type": "rug pull", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1747735728, "native_token_price_usd": 650.34, "tags": [], "lost_amount_usd": 69600.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Non-standard allowance handling in transferFrom conditionally skips allowance enforcement", "severity": "critical", "content": "The `transferFrom` implementation does not consistently enforce ERC20 allowance semantics. After executing `_transfer(sender, recipient, amount)`, the contract only decrements (and effectively checks) the caller\u2019s allowance under a conditional branch: `if (msg.sender != _taxWallet && (sender == uniswapV2Pair || recipient != address(0xdead))) { _approve(sender, msg.sender, allowance - amount); }`. This means calls made by `_taxWallet` bypass allowance consumption entirely, and other edge cases (e.g., transfers to `0xdead`) can behave unexpectedly.\n\nThis is a direct violation of ERC20 expectations: for `transferFrom`, allowance should be validated and reduced for all callers (except standard \u201cinfinite allowance\u201d behavior), regardless of recipient, and without special-casing privileged roles. The current logic allows a privileged address to move tokens from arbitrary senders without authorization, which can include contracts holding reserves (e.g., AMM pairs) or user wallets. This creates an asset-drain backdoor and breaks integration assumptions for wallets/DEXes that rely on standard allowance rules.", "fix_description": "Rewrite `transferFrom` to always require and decrement allowance (optionally supporting `type(uint256).max` as infinite), and remove any `_taxWallet`-based exemption. Example:\n\n```solidity\nfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\n    if (currentAllowance != type(uint256).max) {\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n    }\n    return true;\n}\n```", "focus_areas": ["asset_management", "semantic_verification"], "auditable": true}, {"title": "setTaxWallet is not owner-restricted and uses fee-exclusion as authorization (privilege escalation)", "severity": "high", "content": "`setTaxWallet(address payable newWallet)` is not protected by `onlyOwner` (or any dedicated admin role). Instead, it authorizes callers via `require(_excludedFromFee[msg.sender]);`. The `_excludedFromFee` mapping is intended for fee logic, not access control, and may include multiple addresses (e.g., the contract itself and any other addresses excluded over time). As a result, any address that is (intentionally or accidentally) marked fee-exempt can arbitrarily reassign `_taxWallet`.\n\nThis is particularly dangerous because `_taxWallet` is treated as a privileged role elsewhere in the contract logic. Reassigning it can redirect fee proceeds and, combined with other privileged branches (e.g., special-casing `_taxWallet` in `transferFrom`), can enable unauthorized token movements and loss of funds. Using a mutable \u201cfee exemption\u201d list as an authorization gate conflates concerns and significantly enlarges the set of entities able to seize critical privileges.\n\nEven if the team intends multiple operational accounts to be fee-exempt, they should not automatically gain admin capabilities over sensitive roles.", "fix_description": "Restrict `setTaxWallet` to `onlyOwner` (or a dedicated immutable admin) and consider a 2-step handover pattern. Do not use `_excludedFromFee` for authorization.\n\n```solidity\nfunction setTaxWallet(address payable newWallet) external onlyOwner {\n    require(newWallet != address(0), \"zero address\");\n    _taxWallet = newWallet;\n}\n```", "focus_areas": ["access_control"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:19:19.449614+00:00", "code_visible": true}}
{"id": "ydt_token", "name": "Ydt Token", "chain_id": 56, "block_number": 50273545, "target_contract": "0x3612e4Cb34617bCac849Add27366D8D85C102eFd", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-05/YDTtoken_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1748153811, "native_token_price_usd": 669.73, "tags": [], "lost_amount_usd": 41000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "`proxyTransfer()` authorizes using a user-controlled parameter instead of `msg.sender`", "severity": "critical", "content": "`YDTMainContract.proxyTransfer(address sender, address recipient, uint256 amount, address callerModule)` is intended to be an internal escape hatch that lets approved sub-modules perform raw token movements via `super._transfer(sender, recipient, amount)` (bypassing tax/referral/other logic). However, the function\u2019s authorization check compares a *user-supplied* `callerModule` argument against known module addresses rather than authenticating the *actual caller* (`msg.sender`). As a result, any external account can pass `callerModule` equal to an allowed module address and satisfy the `require`, even though the call did not originate from that module. Because the function also does not enforce that `sender == msg.sender` or that `sender` is otherwise constrained, a successful call enables arbitrary transfers from any address with balance (including protocol-controlled addresses or AMM pair contracts). This breaks the core ERC20 authorization model and can lead to complete loss of user funds and/or liquidity pool reserves.", "fix_description": "Remove `callerModule` from the function signature and authenticate with `msg.sender` only. Example:\n```solidity\nfunction proxyTransfer(address sender, address recipient, uint256 amount) external {\n  require(\n    msg.sender == address(taxModule) ||\n    msg.sender == address(referralModule) ||\n    msg.sender == address(deflationModule) ||\n    msg.sender == address(liquidityModule) ||\n    msg.sender == address(lpTrackingModule),\n    \"Only sub-modules allowed\"\n  );\n  super._transfer(sender, recipient, amount);\n}\n```\nOptionally add per-module constraints on allowable `sender` values (defense in depth).", "focus_areas": ["access_control", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:19:20.230557+00:00", "code_visible": false}}
{"id": "aave_boost", "name": "Aave Boost", "chain_id": 1, "block_number": 22685443, "target_contract": "0xd2933c86216dC0c938FfAFEca3C8a2D6e633e2cA", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-06/AAVEBoost_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1749694667, "native_token_price_usd": 2644.51, "tags": [], "lost_amount_usd": 14800.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "proxyDeposit credits a boosted deposit amount without sourcing/transferring the boost tokens", "severity": "critical", "content": "In proxyDeposit(), the contract conditionally \u201cboosts\u201d a user\u2019s deposit by adding a fixed REWARD to the amount passed into pool.deposit(). The branch condition only checks the contract\u2019s current AAVE balance (aave.balanceOf(address(this)) >= REWARD), but the function never transfers or otherwise sources the additional REWARD amount to the pool for this specific deposit. Instead, it only pulls `amount` AAVE from the caller and then calls `pool.deposit(asset, recipient, amount + REWARD, false)`. This breaks a core accounting invariant: the amount the pool is instructed to credit (amount + REWARD) can exceed the value actually provided for the deposit (amount).\n\nAs a result, if the contract holds at least REWARD AAVE at the time of a call, callers can be credited with REWARD \u201cextra\u201d in the pool without paying that increment. This can be repeated (including with amount = 0), allowing unbacked balances to be minted/credited in the external pool and later withdrawn, draining the pool/boost reserves and/or creating insolvency depending on the pool\u2019s implementation.\n\nThis is a pure code-level value-mismatch bug between transferred-in value and credited deposit value.", "fix_description": "Ensure the boosted portion is actually provided to the pool. Options: (a) transfer REWARD from this contract to the pool (or include it in the deposited token flow) before/when calling deposit, and only call pool.deposit with the total amount actually supplied; or (b) remove the boost from the deposit amount and instead track/airdrop rewards separately. Additionally, enforce `require(amount > 0)` to prevent zero-amount boosted deposits, and ensure the pool pulls exactly the supplied amount.", "focus_areas": ["business_logic", "asset_management"], "auditable": true}, {"title": "proxyDeposit does not validate `asset` and transfers AAVE regardless of the asset being deposited", "severity": "high", "content": "proxyDeposit() accepts an arbitrary `asset` parameter that is forwarded to `pool.deposit(asset, ...)`, but it always executes `aave.safeTransferFrom(msg.sender, address(this), amount)` regardless of what `asset` is. This decouples the token collected from the user (always AAVE) from the token the pool is instructed to credit (user-controlled `asset`). The function therefore cannot guarantee the fundamental invariant \u201cthe token transferred in equals the token deposited/credited,\u201d and it relies on external pool behavior/allowances to reconcile this mismatch.\n\nThis flaw can lead to incorrect crediting and unexpected asset flows: users may pay AAVE while being credited for a different token, or the pool may attempt to pull `asset` from this contract even though only AAVE was collected. Combined with the boost logic (adding REWARD to the credited amount), this greatly amplifies the impact by allowing unbacked crediting in whichever asset the pool accepts, and undermines any assumptions about solvency and correct accounting.\n\nBecause `asset` is fully user-controlled and no validation is performed, the function\u2019s behavior is ambiguous and unsafe under typical ERC20/pool semantics.", "fix_description": "Bind the transferred token to the deposited token. If only AAVE deposits are intended: `require(asset == aave, \"ASSET_NOT_AAVE\");` and keep all flows in AAVE. Otherwise, change the transfer to `asset.safeTransferFrom(...)`, ensure allowances are set for that asset, and define explicitly how (and in which token) any boost is funded and deposited (no mixed-token implicit behavior).", "focus_areas": ["input_validation", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:19:40.419064+00:00", "code_visible": false}}
{"id": "gradient_maker_pool", "name": "Gradient Maker Pool", "chain_id": 1, "block_number": 22765113, "target_contract": "0x37Ea5f691bCe8459C66fFceeb9cf34ffa32fdadC", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-06/GradientMakerPool_exp.sol", "defihacklabs_vuln_type": "Price Oracle Manipulation", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1750657331, "native_token_price_usd": 2413.17, "tags": [], "lost_amount_usd": 5000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Reward accounting uses inconsistent share basis (lpShares vs token+eth), enabling reward overpayment and ETH drain", "severity": "critical", "content": "The contract\u2019s reward distribution accounting is internally inconsistent about what a \u201cshare\u201d is. In `_updatePool`, `accRewardPerShare` is increased by `ethAmount / pool.totalLPShares`, which defines rewards on an LP-share basis. However, in `provideLiquidity()` and `withdrawLiquidity()`, pending rewards are computed using `userLiquidity = mm.tokenAmount + mm.ethAmount` and `pending = userLiquidity * accRewardPerShare - mm.rewardDebt`, and `mm.rewardDebt` is set using the same `token+eth` basis. In contrast, `claimReward()` computes `accumulated` as `mm.lpShares * accRewardPerShare`, and subtracts `mm.rewardDebt` that was previously set using a different unit. Because `mm.lpShares` and `(mm.tokenAmount + mm.ethAmount)` are not guaranteed to be equal (they can diverge due to LP-share minting math and pool state), this unit mismatch makes `reward = accumulated - rewardDebt + pendingReward` incorrect and manipulable. Depending on the direction of the mismatch, this can allow claiming more ETH than deserved (draining contract ETH), or can trigger underflow reverts that lock users out of reward claiming/withdraw flows.\n", "fix_description": "Use a single unit for reward accounting everywhere (recommended: LP shares).\n- In `provideLiquidity()`/`withdrawLiquidity()`, compute pending as: `pending = (mm.lpShares * pool.accRewardPerShare) / SCALE - mm.rewardDebt; mm.pendingReward += pending;`.\n- After updating `mm.lpShares` (mint/burn), set: `mm.rewardDebt = (mm.lpShares * pool.accRewardPerShare) / SCALE;`.\n- Remove any use of `mm.tokenAmount + mm.ethAmount` from reward math (and avoid summing raw ETH + token amounts as \u201cliquidity\u201d).", "focus_areas": ["business_logic", "arithmetic"], "auditable": true}, {"title": "Internal pool totals are not tightly coupled to actual reserves, allowing withdrawals/rewards to be computed from inconsistent state", "severity": "high", "content": "Withdrawals and rewards rely on internal accounting variables (`pool.totalEth`, `pool.totalToken`, `pool.totalLiquidity`, `pool.rewardBalance`) rather than enforcing consistency with the contract\u2019s actual ETH/ERC20 balances and segregating what portion of ETH is \u201cliquidity\u201d vs \u201crewards.\u201d Assets can move in/out via orderbook-related transfers and reward payouts, but there is no invariant that `pool.totalEth/totalToken` equals the real reserves backing LP shares at the time of withdrawal. Additionally, `pool.rewardBalance` is incremented when fees are distributed but is not decremented on reward payouts, so it cannot be used as an enforceable escrow constraint. As a result, `withdrawLiquidity()` can compute `actualEthWithdraw`/`actualTokenWithdraw` from stale/misaligned totals and attempt to pay users from the global contract balance, enabling insolvency and making any accounting bug (including the reward share-basis mismatch) materially worse: users may receive value that is not actually reserved for them, potentially draining ETH that should back other LPs or other pools.\n", "fix_description": "Couple accounting to real reserves and enforce solvency:\n- Segregate and escrow rewards per pool (track `pool.rewardBalance` as real reserved ETH and decrement it on payout; require `reward <= pool.rewardBalance`).\n- Ensure `pool.totalEth`/`pool.totalToken` reflect only withdrawable liquidity (exclude reward escrow) and reconcile with actual balances (or derive from balances directly).\n- In `withdrawLiquidity()`, cap transfers to available balances and add invariant checks after orderbook transfers/reward distribution to prevent state drift.", "focus_areas": ["asset_management", "semantic_verification"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:20:24.674805+00:00", "code_visible": true}}
{"id": "meta_pool", "name": "Meta Pool", "chain_id": 1, "block_number": 22722910, "target_contract": "0x48AFbBd342F64EF8a9Ab1C143719b63C2AD81710", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-06/MetaPool_exp.sol", "defihacklabs_vuln_type": "Access Control", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1750147367, "native_token_price_usd": 2510.96, "tags": [], "lost_amount_usd": 132000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "ERC4626 share pricing relies on manipulable spot `totalAssets()` (raw vault balance) allowing incorrect share issuance", "severity": "critical", "content": "The vault implements ERC4626-style accounting where share issuance/redemption is derived from the instantaneous ratio between `totalSupply()` and `totalAssets()`, and `totalAssets()` is effectively the current underlying balance held by the vault (`balanceOf(address(this))` / native ETH balance as wrapped). This is unsafe when `totalAssets()` can be influenced inside the same block/transaction or via external market interactions, because deposits/mints will compute shares using a spot value that is not an internally-accounted, manipulation-resistant measure of managed assets.\n\nAs a result, the protocol can mint shares at an exchange rate that does not reflect the vault\u2019s true economic backing, creating under-collateralized shares (i.e., shares that can later be redeemed/swapped for more assets than were contributed). This is a classic ERC4626 \u201cspot accounting / donation / inflation\u201d class issue: using raw on-chain balances as the single source of truth for share price, without virtual shares/assets, slippage controls, TWAP/oracle anchoring, or synchronization mechanisms, allows attackers to transiently skew the conversion and extract value from the system.\n\nAffected flows include `depositETH(address)`, `ERC4626Upgradeable.deposit`, `mint`, and `_convertToShares`, all of which trust `totalAssets()` as an honest pricing input.", "fix_description": "Make share pricing manipulation-resistant by removing dependence on raw spot balances:\n- Prefer internal accounting: maintain `totalManagedAssets` in storage updated only during controlled inflows/outflows, and have `totalAssets()` return that value (not `balanceOf(this)`).\n- Add ERC4626 inflation protection via virtual shares/assets (offset) in `_convertToShares/_convertToAssets`.\n- If an external price relationship is required, anchor to an oracle/TWAP and enforce deviation bounds; additionally consider deposit/mint functions that accept `minShares` (slippage) and revert if the spot conversion is unfavorable.\n", "focus_areas": ["economic_attacks", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:19:53.693704+00:00", "code_visible": false}}
{"id": "rant_token", "name": "Rant Token", "chain_id": 56, "block_number": 52974382, "target_contract": "0xc321AC21A07B3d593B269AcdaCE69C3762CA2dd0", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-07/RANTToken_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1751728596, "native_token_price_usd": 656.39, "tags": [], "lost_amount_usd": 204000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Token transfer logic can arbitrarily reduce AMM pair token balance and force reserve updates (unauthorized reserve mutation)", "severity": "critical", "content": "The token implements \u201cauto-burn/liquidity burn\u201d mechanics that directly mutate the UniswapV2 pair\u2019s token balance and then calls `sync()`. Specifically, helper functions such as `_sellBurnLiquidityPairTokens()` perform `super._transfer(uniswapPair, 0xdead, ...)` and `super._transfer(uniswapPair, rant_node, ...)`, and `_autoBurnLiquidityPairTokens()` reduces the pair\u2019s balance via `super._transferSub(uniswapPair, amountToBurn)` (without a normal ERC20 transfer flow) before calling `pair.sync()`.\n\nThis is fundamentally unsafe: the token contract should not be able to move tokens out of the AMM pair address outside of the pair\u2019s own `swap/mint/burn` flows. Pair balances represent LP-owned reserves; changing them unilaterally breaks the constant-product invariant and allows the pool price to be arbitrarily shifted at transfer-time. Because these routines are reachable during ordinary ERC20 transfers (not only privileged/admin actions), any user can trigger reserve-reduction + `sync()` at chosen moments, enabling severe economic manipulation and draining of the counter-asset from the pool.\n\nIn addition, `_transferSub` mutates balances without emitting a `Transfer`, further violating ERC20 expectations and complicating integrations and monitoring.", "fix_description": "Remove any logic that transfers tokens from `uniswapPair` or directly decrements its balance, and remove any `pair.sync()` calls from token transfer paths. If burns/redistributions are required, collect fees into `address(this)` during transfers/swaps and burn/redistribute only from `address(this)` (or via standard pair `burn` by LPs). Concretely: delete/disable `_sellBurnLiquidityPairTokens()` and `_autoBurnLiquidityPairTokens()` (and their call sites), and eliminate all `super._transfer(uniswapPair, ...)` / `super._transferSub(uniswapPair, ...)` occurrences.", "focus_areas": ["asset_management", "economic_attacks"], "auditable": true}, {"title": "Liquidity add/remove detection relies on manipulable pair balances/reserves, causing unsafe branching in `_transfer`", "severity": "high", "content": "The contract attempts to detect \u201cadd liquidity\u201d and \u201cremove liquidity\u201d events in `_isAddLiquidity()` / `_isRemoveLiquidity()` by comparing the pair\u2019s stored reserves to the current `balanceOf(tokenOther)` in the pair. This heuristic is not a reliable indicator of liquidity operations because pair balances can be changed transiently within a transaction (e.g., swaps, flash swaps, and direct transfers) before reserves are updated. As a result, `_transfer`\u2019s branching that depends on these checks can be steered into unintended code paths by manipulating external state.\n\nIn this codebase, those checks influence whether special transfer restrictions apply and whether burn/sync routines execute. When security-critical behavior (such as reserve-affecting logic, fee logic, or trading gates) depends on these fragile classifications, attackers can intentionally misclassify actions to bypass intended safeguards or to trigger sensitive operations at controlled times. This compounds the risk of any reserve-affecting logic and can make economic manipulation deterministic.\n\nOverall, liquidity-event inference based on balance/reserve deltas inside the token contract is unsafe to use for enforcing invariants or gating high-impact behavior.", "fix_description": "Remove `_isAddLiquidity` / `_isRemoveLiquidity`-based branching from `_transfer` and do not use pair balance/reserve comparisons to infer liquidity events. If special handling is required, enforce it via explicit trusted entry points (e.g., only the router), dedicated functions, or owner-controlled toggles with clear scope. Ensure no security-critical action depends on externally manipulable reserve/balance heuristics.", "focus_areas": ["business_logic", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:20:27.344025+00:00", "code_visible": false}}
{"id": "swapp_staking", "name": "Swapp Staking", "chain_id": 1, "block_number": 22957532, "target_contract": "0x245a551ee0F55005e510B239c917fA34b41B3461", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-07/SWAPPStaking_exp.sol", "defihacklabs_vuln_type": "Incorrect Reward calculation", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1752979811, "native_token_price_usd": 3758.64, "tags": [], "lost_amount_usd": 32196.28, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Staking/withdrawal accepts arbitrary ERC20 token addresses (missing token whitelist), enabling withdrawal of unrelated assets held by the contract", "severity": "critical", "content": "`deposit(tokenAddress, ...)` and `emergencyWithdraw(tokenAddress)` treat `tokenAddress` as an untrusted user input but do not restrict it to a predefined set of supported staking assets. The only gate is `checkStableCoin(tokenAddress)` (i.e., \u201cstable vs non-stable\u201d), which is not a security boundary and still leaves an effectively unbounded set of ERC20s that can be used with the staking accounting.\n\nAs a result, the contract will (a) accept deposits for any non-stable ERC20 and credit `balances[user][tokenAddress]`, and later (b) allow `emergencyWithdraw(tokenAddress)` to transfer `balances[user][tokenAddress]` of that same token out of the contract. This becomes critical because the contract also custody-holds other non-stable tokens as part of its internal strategy/operations (e.g., yield-bearing tokens such as Compound cTokens received/held during stablecoin compounding). Since `emergencyWithdraw` does not verify that the token is a valid staking pool asset nor that the withdrawn amount corresponds to a segregated pool balance, a user can create/credit a balance for an arbitrary token and use emergency withdrawal to extract any holdings of that token from the contract, draining assets that back other users\u2019 positions.", "fix_description": "Introduce a strict allowlist of stakeable tokens and enforce it in all entry points that use `tokenAddress` (at minimum: `deposit`, `withdraw`, `emergencyWithdraw`, and any epoch initialization logic).\n\n- Add `mapping(address => bool) public isAllowedStakeToken;` with owner/admin setter.\n- `require(isAllowedStakeToken[tokenAddress], \"unsupported token\");` in `deposit/withdraw/emergencyWithdraw`.\n- Explicitly disallow strategy/yield tokens (e.g., cTokens) from being treated as stakeable assets, or segregate them into a different contract/address that is never reachable via user-supplied `tokenAddress`.\n- Ensure emergency withdrawal only applies to supported staking pools and cannot move assets outside the intended pool accounting.", "focus_areas": ["input_validation", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:20:00.248026+00:00", "code_visible": false}}
{"id": "abcc_app", "name": "Abcc App", "chain_id": 56, "block_number": 58615054, "target_contract": "0x1bC016C00F8d603c41A582d5Da745905B9D034e5", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-08/ABCCApp_exp.sol", "defihacklabs_vuln_type": "Lack of Access Control", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1755959526, "native_token_price_usd": 880.21, "tags": [], "lost_amount_usd": 10100.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "Public addFixedDay allows arbitrary modification of global time offset used in reward accrual", "severity": "critical", "content": "The contract\u2019s reward accrual and claimability calculations rely on a mutable global time offset variable (`fixedDay`) that is added to `block.timestamp`. Specifically, `getCanClaimUSDT()` computes elapsed time as `diffSecond = block.timestamp + getFixedDay() - user.lastClaimTime`, derives `diffDay = diffSecond / DAY`, and uses this to calculate how much USDT-equivalent value is claimable. Both `deposit()` and `claimDDDD()` persist `user.lastClaimTime = block.timestamp + getFixedDay()`, assuming the offset is trusted and stable. However, `addFixedDay(uint target)` is publicly callable with no access control, allowing any address to arbitrarily increase `fixedDay` (or reset it when `target == 0`) at any time. Because `fixedDay` is global and directly affects the \u201ctime passed\u201d for all users, an attacker can artificially inflate elapsed time and immediately satisfy day-based accrual requirements, enabling premature and oversized claims limited only by contract liquidity. This breaks core accounting invariants (time-based vesting/accrual) and can lead to rapid depletion of payout tokens and systemic disruption of user balances/claim schedules.", "fix_description": "Restrict `addFixedDay` to an authorized role (e.g., `onlyOwner`) and bound/validate adjustments. Prefer removing the global offset from accounting altogether (store raw `block.timestamp` in `lastClaimTime` and do not add mutable offsets in state updates). Minimal patch:\n\n```solidity\nfunction addFixedDay(uint256 target) external onlyOwner {\n    if (target == 0) fixedDay = 0;\n    else fixedDay += target;\n}\n```\n\nAlso avoid persisting `lastClaimTime` with any offset; store raw timestamps and, if an admin adjustment is truly needed, apply it in a controlled, capped manner (ideally timelocked).", "focus_areas": ["access_control", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:19:53.666633+00:00", "code_visible": true}}
{"id": "mim_spell3", "name": "Mim Spell3", "chain_id": 1, "block_number": 23504544, "target_contract": "0x46f54d434063e5F1a2b2CC6d9AAa657b1B9ff82c", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-10/MIMSpell3_exp.sol", "defihacklabs_vuln_type": "Bypassed Insolvency Check", "exploit_file": null, "evm_version": "shanghai", "exploit_timestamp": 1759582439, "native_token_price_usd": 4489.84, "tags": [], "lost_amount_usd": 1700000.0, "dataset_version": "v1", "source_available": true, "status": "ready", "reference_findings": [{"title": "cook() relies on externally-supplied numeric action IDs without strict decoding/validation, allowing action dispatch to execute unintended logic paths", "severity": "critical", "content": "The `cook(uint8[] actions, uint256[] values, bytes[] datas)` dispatcher treats the externally-provided `actions[i]` \u201cmagic numbers\u201d as the sole source of truth for which internal routine to execute (e.g., borrow vs repay), and then ABI-decodes `datas[i]` according to the selected branch. This design makes correctness and safety dependent on an unambiguous, immutable mapping of action IDs to semantics across versions/deployments, and on callers always providing correctly encoded calldata for that exact branch.\n\nIf the action-ID mapping is inconsistent (e.g., due to differing constant/enum ordering across builds/versions, or assumptions made by integrators), `cook()` can route to the wrong internal function. Because solvency enforcement in `cook()` is driven by action categories/flags (e.g., `needsSolvencyCheck`) rather than by observing actual state deltas (debt increased / collateral decreased), mis-dispatch can execute a debt-increasing path (borrow) without the intended preconditions and post-conditions, enabling extraction of assets from the protocol.\n\nMore generally, the absence of strict per-action input validation (including rejecting malformed/incorrectly-sized `datas[i]`) makes it harder to guarantee that each action is executed only with the expected parameters and invariants, increasing the blast radius of any misrouting or integration mismatch.", "fix_description": "1) Make action IDs unambiguous and immutable across deployments (e.g., a single `enum Action { ... }` whose ordering never changes; avoid redeclaring/reordering constants across versions).\n2) Add strict per-action calldata validation in `cook()` (e.g., decode using the exact expected tuple type per action and revert on failure/incorrect length).\n3) Add a safety net: after processing the batch, enforce solvency whenever the user\u2019s debt increased or collateral decreased (compute/track deltas), rather than relying solely on action IDs/flags to decide if a solvency check is needed.", "focus_areas": ["execution_flow", "input_validation"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:20:23.082264+00:00", "code_visible": false}}
{"id": "lavalending_202410", "name": "LavaLending", "chain_id": 42161, "block_number": 259645907, "target_contract": "0x3Ff516B89ea72585af520B64285ECa5E4a0A8986", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-10/LavaLending_exp.sol", "defihacklabs_vuln_type": "Business Logic Flaw", "exploit_file": "LavaLending_exp.sol", "evm_version": null, "exploit_timestamp": 1727881870, "native_token_price_usd": 2349.81, "tags": [], "lost_amount_usd": 340000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Collateral valuation relies on manipulable LP token on-chain state instead of a manipulation-resistant oracle", "severity": "critical", "content": "The LendingPool allows an LP token to be enabled as collateral, and the user\u2019s borrowing power/health factor is computed using a price/valuation derived from the LP\u2019s own on-chain accounting (e.g., reserves/virtual price/spot conditions) rather than a manipulation-resistant oracle. Because this valuation can be significantly moved within a single transaction (e.g., by temporarily shifting pool balances or internal share accounting), `getUserAccountData()` can report an inflated collateral value that does not reflect the LP\u2019s fair market value. The protocol then uses this inflated value immediately in the same execution flow to permit borrowing, without enforcing a TWAP window, sanity bounds, or delayed/averaged pricing. As a result, an attacker can momentarily inflate the collateral valuation, deposit the LP token, and borrow assets far in excess of real economic backing, leaving the protocol undercollateralized once the LP state normalizes. The impact is loss of funds from the lending reserves and protocol insolvency for affected markets.", "fix_description": "Do not whitelist LP tokens as collateral unless priced via a manipulation-resistant oracle. Replace any spot/reserve-derived LP pricing with a robust approach: use Chainlink feeds for underlying assets and compute LP fair value from verified reserves using TWAP/observation windows; add deviation bounds (circuit breakers) that reject prices outside configured thresholds. In `borrow`, re-check health factor using the manipulation-resistant price and optionally enforce same-block price-change guards for collateral assets.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}, {"title": "Missing isolation controls (caps/debt ceilings) allow recursive collateral amplification using deposited borrowed assets", "severity": "high", "content": "The LendingPool design permits highly composable deposit/borrow loops where assets obtained via borrowing can be immediately redeposited as collateral (including through helper contracts), increasing account borrowing power without friction. In isolation this may be acceptable, but when combined with any collateral whose valuation can be temporarily overstated, the absence of risk controls (isolation mode, collateral caps, per-asset borrow caps/debt ceilings) enables rapid recursive amplification of effective collateral value. This lets an attacker scale an initially inflated collateral position into a much larger borrow capacity than intended by risk parameters, draining multiple reserves before the system can be liquidated or before prices revert. The result is that a single weak collateral type can be used to extract disproportionate liquidity across the protocol, and the blast radius is not limited to the affected collateral market.", "fix_description": "Introduce isolation mode and risk caps for non-bluechip/risky collateral (especially LP tokens): set a collateral cap and a low debt ceiling; enforce per-asset borrow caps; and consider restricting same-transaction/ same-block reuse of newly borrowed assets as collateral for raising borrow power (e.g., snapshot-based collateral accounting or delayed collateral activation for flagged assets).", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:20:33.758377+00:00", "code_visible": false}}
{"id": "ak", "name": "Ak1111", "chain_id": 56, "block_number": 44280828, "target_contract": "0xc3B1b45e5784A8efececfC0BE2E28247d3f49963", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-11/Ak1111_exp.sol", "defihacklabs_vuln_type": "Access Control", "exploit_file": "Ak1111_exp.sol", "evm_version": null, "exploit_timestamp": 1732423253, "native_token_price_usd": 660.45, "tags": [], "lost_amount_usd": 31500.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Unrestricted `nonblockingLzReceive1` exposes token credit/mint logic to arbitrary callers", "severity": "critical", "content": "The contract exposes a non-standard entry point `nonblockingLzReceive1(...)` that is callable by any external account and directly reaches the OFT credit path (`_creditTo`), which ultimately mints tokens (`_mint`) to a user-controlled address for a user-controlled amount. This bypasses the intended LayerZero receive authentication and execution flow, where minting should only occur after (1) `lzReceive` verifies `msg.sender` is the LayerZero endpoint, (2) the source chain/address matches a configured trusted remote, and (3) the message is processed via the NonblockingLzApp self-call pattern.\n\nIn the current implementation, `nonblockingLzReceive1` performs no caller checks (not endpoint-only, not self-call-only) and does not validate that the call corresponds to an authenticated/recorded LayerZero message. As a result, the core bridge invariant (tokens are minted only when a valid cross-chain transfer is proven) is broken: any account can mint arbitrary supply to any address, which can lead to total loss of funds in integrated liquidity pools/lending markets and irreparable token supply corruption.\n", "fix_description": "Remove `nonblockingLzReceive1` entirely. If a helper is absolutely required, make it `internal` or strictly gate it to the authenticated LayerZero path (e.g., `require(msg.sender == address(this))` and/or `require(msg.sender == address(lzEndpoint))` plus trusted-remote verification). Ensure parameter semantics are corrected (do not treat `_nonce` as `_amount`).", "focus_areas": ["access_control", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:20:42.258070+00:00", "code_visible": true}}
{"id": "chisale", "name": "ChiSale", "chain_id": 1, "block_number": 21132837, "target_contract": "0x050163597D9905bA66400f7B3CA8f2ef23DF702D", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-11/ChiSale_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "ChiSale_exp.sol", "evm_version": null, "exploit_timestamp": 1730947091, "native_token_price_usd": 2897.52, "tags": [], "lost_amount_usd": 16300.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Constructor never sets maxBonusThreshold due to unreachable condition (broken sale cap initialization)", "severity": "critical", "content": "The constructor intends to initialize `maxBonusThreshold` to the final entry in `bonusThresholds` (i.e., the maximum token amount covered by the configured bonus schedule / sale cap). However, the assignment is guarded by `if (i > bonusThresholds.length - 1)`, which is impossible because `i` iterates from `0` to `bonusThresholds.length - 1`. Consequently, `maxBonusThreshold` remains `0` after deployment.\n\n`buy()` relies on `maxBonusThreshold` to clamp purchases, but also contains a fallback branch `if (maxBonusThreshold < tokenBalance) { maxBonusThreshold = tokenBalance; }`, which silently replaces the intended cap with the contract\u2019s current token balance. This breaks the sale\u2019s core business logic: depending on when/how tokens are deposited, purchases may be clamped to `0` (leading to inconsistent behavior and edge cases in bonus logic), or the first buyer may be allowed to buy up to the entire inventory regardless of the intended thresholds/cap.\n\nBecause the cap governs both purchase sizing and how the tiered bonus schedule is expected to progress, incorrect initialization enables buyers to interact with the sale in unintended states and can be combined with bonus edge cases to extract tokens under conditions the design did not permit.", "fix_description": "Initialize `maxBonusThreshold` deterministically to the last threshold after populating tiers (or when `i == bonusThresholds.length - 1`). Remove the token-balance-based mutation in `buy()` so deposits cannot change the cap.\n\nExample:\n```solidity\nfor (uint8 i = 0; i < bonusThresholds.length; i++) {\n  if (i > 0) require(bonusThresholds[i] > bonusThresholds[i-1]);\n  bonusTiers.push(BonusTier({ percentage: bonusPercentages[i], threshold: bonusThresholds[i] }));\n}\nmaxBonusThreshold = bonusThresholds[bonusThresholds.length - 1];\n```\nAdditionally, ensure `buy()` clamps by remaining inventory and rejects zero-sized buys (`require(tokensToBuy > 0)`).", "focus_areas": ["business_logic", "semantic_verification"], "auditable": true}, {"title": "calculateBonusTokens() can increment bonusIndex out of bounds due to incorrect boundary check", "severity": "high", "content": "`calculateBonusTokens()` mutates the global `bonusIndex` as tiers are exhausted. When a tier threshold is reached, it attempts to advance to the next tier with:\n\n```solidity\nif (bonusIndex < bonusTiers.length) {\n    bonusIndex += 1;\n}\n```\n\nThis condition is off by one. When `bonusIndex == bonusTiers.length - 1` (last valid tier), the condition is true and increments `bonusIndex` to `bonusTiers.length`, which is not a valid index. Subsequent iterations of the `while (_boughtTokens > 0)` loop (or later calls) can then attempt to read `bonusTiers[bonusIndex]` before a safe termination check is applied for that iteration, causing an out-of-bounds array access and reverting.\n\nThis is a correctness and availability issue for the sale: a purchase that exhausts the final tier (or crosses it) can corrupt the bonus progression state and brick purchases and related view functions that index `bonusTiers` using `bonusIndex`. It also creates fragile, hard-to-reason-about bonus behavior around tier boundaries, undermining the intended constraints of the sale schedule.", "fix_description": "Prevent `bonusIndex` from ever being used past the array length and guard at the top of each loop iteration.\n\nExample:\n```solidity\nwhile (_boughtTokens > 0) {\n  if (bonusIndex >= bonusTiers.length) break;\n  ...\n  if (_tokensSold + _boughtTokens >= threshold) {\n    ...\n    _tokensSold = threshold;\n    if (bonusIndex + 1 < bonusTiers.length) bonusIndex += 1;\n    else bonusIndex = uint8(bonusTiers.length);\n  } else {\n    ...\n    _boughtTokens = 0;\n  }\n}\n```\nAlso harden any functions reading `bonusTiers[bonusIndex]` (e.g., return 0 when `bonusIndex >= bonusTiers.length`).", "focus_areas": ["execution_flow", "semantic_verification"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:20:42.972402+00:00", "code_visible": true}}
{"id": "cow", "name": "CoW", "chain_id": 1, "block_number": 21135437, "target_contract": "0x9008D19f58AAbD9eD0D60971565AA8510560ab41", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-11/CoW_exp.sol", "defihacklabs_vuln_type": "Access Control", "exploit_file": "CoW_exp.sol", "evm_version": null, "exploit_timestamp": 1730978435, "native_token_price_usd": 2897.52, "tags": [], "lost_amount_usd": 59000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Public simulation helper performs unrestricted DELEGATECALL in the settlement contract context", "severity": "critical", "content": "The settlement contract inherits `StorageAccessible`, which exposes `simulateDelegatecall(target, data)` publicly. Despite being intended as a \u201csimulation\u201d primitive, the implementation performs a real `DELEGATECALL` into an attacker-chosen `target` using the settlement contract\u2019s execution context (its `address(this)`, permissions, ETH balance, and token allowances). The wrapper pattern that forces a revert to return data does not make the delegatecall \u201cread-only\u201d: during the delegatecall, attacker-controlled code can still execute arbitrary external calls as the settlement contract (e.g., ERC20 `transfer/approve`, calling other protocols, triggering callbacks), and those external effects occur before the forced revert. This effectively bypasses all authorization assumptions around who is allowed to perform operations as the settlement contract and turns the settlement into an arbitrary execution gadget. If the settlement holds any ETH/tokens (fees, dust, mistakenly sent funds), or has meaningful approvals/permissions (e.g., to a vault/relayer), this can directly lead to asset loss or irreversible state changes in external contracts initiated from the settlement address.\n", "fix_description": "Do not ship the settlement with `StorageAccessible` inheritance, or strictly restrict it. Recommended: remove `StorageAccessible` from production `GPv2Settlement`. If retention is required, gate `simulateDelegatecall`/`simulateDelegatecallInternal` behind strong access control (e.g., `onlyOwner`/governance) and/or move simulation to a separate helper contract that holds no funds/approvals. If the intent is off-chain only, enforce STATICCALL semantics (cannot be done with DELEGATECALL) or ensure the function cannot be used in state-changing transactions (e.g., only callable via a dedicated eth_call-only endpoint is not enforceable on-chain; therefore access control/removal is required).", "focus_areas": ["access_control", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:20:46.135532+00:00", "code_visible": false}}
{"id": "mft", "name": "MFT", "chain_id": 56, "block_number": 44097963, "target_contract": "0x29Ee4526e3A4078Ce37762Dc864424A089Ebba11", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-11/MFT_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "MFT_exp.sol", "evm_version": null, "exploit_timestamp": 1731874636, "native_token_price_usd": 619.21, "tags": [], "lost_amount_usd": 33700.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Token contract can arbitrarily mutate AMM pair balance and force reserve updates (direct pair-balance burn + sync)", "severity": "critical", "content": "The contract implements a non-standard \u201cLP burn\u201d mechanic that directly decrements the token balance attributed to the AMM pair address (`_balances[_mainPair]`) and then calls `pair.sync()`. This occurs (a) automatically during normal sells via `_tokenTransfer()` calling `burnLiquidityPairTokens(tAmount)` before `_startTime1`, and (b) via an externally callable privileged function `burnLiquidityPairToken(uint256 fee)` gated by a hardcoded EOA. This design is fundamentally unsafe with UniswapV2/PancakeSwap pairs: the pair\u2019s pricing and safety checks assume token balances/reserves change only through standard ERC20 transfers and swaps that preserve the constant-product invariant. By modifying `_balances[_mainPair]` without the pair initiating a transfer, the token can unilaterally desynchronize and re-synchronize reserves, breaking invariants and enabling severe economic attacks (reserve manipulation, incorrect swap accounting) and/or pool malfunction. Because the token has unilateral write access to the pair\u2019s balance, any mechanism in the pair/router that relies on reserve/balance relationships can be subverted, risking total loss of the counter-asset liquidity and/or permanent trading disruption.", "fix_description": "Remove all logic that mutates `_balances[_mainPair]` (or any AMM pair) without an ERC20 transfer initiated by the pair. Concretely: delete `burnLiquidityPairToken()` and remove the `burnLiquidityPairTokens(tAmount)` call path from `_tokenTransfer()`. If \u201cLP burn\u201d is desired, burn only LP tokens that the project actually holds (e.g., `IERC20(address(pair)).transfer(0xdead, amountLP)`) and never call `pair.sync()` from token transfer logic.", "focus_areas": ["economic_attacks", "business_logic"], "auditable": true}, {"title": "ERC20 transfer hook performs external AMM swaps during sells, coupling transfers to mutable pool state", "severity": "high", "content": "On sell transfers (when `to` is a swap pair), `_transfer()` conditionally triggers fee processing that swaps tokens via the router (`swapTokenForFund(...)`) within the same transfer execution. This causes ERC20 `transfer` semantics to include external calls into the AMM, making transfers dependent on and able to modify pool state mid-transfer. Even with the `inSwap` flag, this architecture creates dangerous state coupling: the contract can execute swaps at attacker-influenced times/sizes (based on sell amount and contract balance) while other token mechanics simultaneously affect pair state (e.g., sync/burn behavior). As a result, the pool\u2019s balance/reserve relationship can be manipulated within a single transaction flow, and assumptions made by the pair about orderly reserve updates and invariant preservation become unreliable. This increases the attack surface for reserve/balance manipulation and makes economic exploits significantly easier to engineer compared to a design where fee conversion is explicit, isolated, and not executed inside user transfers.", "fix_description": "Do not call the router (or any external AMM contract) from `_transfer()`/`_tokenTransfer()`. Instead, accumulate fees in the token contract and provide a separate `processFees()` function (optionally permissioned/keeper-driven) with rate limits and max swap caps. Ensure fee processing cannot run in the same code path as any mechanism that alters pair balances/reserves (and remove any pair-balance mutation entirely).", "focus_areas": ["execution_flow", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:21:28.813282+00:00", "code_visible": true}}
{"id": "mainnetsettler", "name": "MainnetSettler", "chain_id": 1, "block_number": 21230767, "target_contract": "0x70bf6634eE8Cb27D04478f184b9b8BB13E5f4710", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-11/MainnetSettler_exp.sol", "defihacklabs_vuln_type": "Access Control", "exploit_file": "MainnetSettler_exp.sol", "evm_version": null, "exploit_timestamp": 1732127687, "native_token_price_usd": 3359.82, "tags": [], "lost_amount_usd": 66000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Permissionless action allows arbitrary external call with user-controlled calldata (BASIC), enabling unauthorized token transfers via existing allowances", "severity": "critical", "content": "The `basicSellToPool` action is implemented as a generic, user-controlled external call primitive: it accepts an arbitrary `pool` address and arbitrary calldata `data`, optionally patches an amount into `data` at a user-provided `offset`, and then executes `pool.call(data)`.\n\nWhile intended to interact with AMM pools, the code does not enforce that `pool` is a valid pool/router or that `data` targets a swap function. The only guard (`_isRestrictedTarget(pool)`) is insufficient because it blocks only a small set of known \u201cconfused deputy\u201d targets, and does not prevent calling arbitrary contracts such as ERC20 token contracts.\n\nAs a result, any permissionless entrypoint/dispatcher that exposes the `BASIC` action allows an untrusted caller to make the Settler contract call arbitrary functions on arbitrary contracts with `msg.sender == Settler`. This is particularly dangerous because many users grant token allowances to the Settler; an attacker can craft calldata to invoke `ERC20.transferFrom(victim, attacker, amount)` on the token contract, causing tokens to be pulled from any victim that has approved Settler, without requiring any victim signature or permit.\n\nImpact: theft of approved third-party funds (and, depending on flows, also any tokens temporarily held by the Settler during execution).", "fix_description": "Remove or strictly constrain the `BASIC` primitive in permissionless contexts:\n- Enforce an allowlist of valid pool/router contracts (or factory-derived pool verification) for `pool`.\n- Enforce an allowlist of permitted function selectors and validate calldata layout; reject anything else.\n- Explicitly disallow `pool == address(sellToken)` and, more generally, disallow calling token contracts as `pool`.\n- If `BASIC` must remain generic, require that the caller is the owner of the funds being spent (prevent using third-party allowances), or redesign to transfer exact amounts to known pools rather than arbitrary calls.", "focus_areas": ["access_control", "input_validation"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:21:28.524298+00:00", "code_visible": true}}
{"id": "matez", "name": "Matez", "chain_id": 56, "block_number": 44222631, "target_contract": "0x326FB70eF9e70f8f4c38CFbfaF39F960A5C252fa", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-11/Matez_exp.sol", "defihacklabs_vuln_type": "Integer Truncation", "exploit_file": "Matez_exp.sol", "evm_version": null, "exploit_timestamp": 1732248647, "native_token_price_usd": 633.77, "tags": [], "lost_amount_usd": 80000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Unsafe downcast of user-supplied stake amount (uint256\u2192uint128) breaks payment enforcement and decouples accounting from actual tokens transferred", "severity": "critical", "content": "In `stake(uint256 amnt)`, the contract records the user\u2019s stake using the full `amnt` value (e.g., `selfInvest`, `directInvest`, `teamInvest`, and `orders[].amount`) but enforces payment using a different value: `amntin = estimateAmountOut(..., uint128(amnt), 1)` and then `depositToken.transferFrom(msg.sender, address(this), amntin)`. This introduces a critical mismatch: the user-controlled `amnt` is narrowed via `uint128(amnt)` before quoting, which truncates the upper 128 bits. For values `amnt > type(uint128).max`, the cast silently wraps, potentially yielding a very small number (including zero). As a result, the contract can accept a stake that is accounted as extremely large while requiring an arbitrarily small (or zero) `depositToken` transfer. Because reward eligibility and subsequent payouts (e.g., `claim(... typ==3 ...)`) rely on the inflated internal accounting rather than the actual tokens received, an attacker can satisfy thresholds and farm/drain rewards without providing commensurate deposits. This is a direct loss-of-funds and economic integrity failure caused by unsafe type conversion and unbound accounting.", "fix_description": "Bind accounting to the actual paid amount and remove/guard the narrowing cast. At minimum:\n- Add `require(amnt <= type(uint128).max, \"amount too large\");` before calling `estimateAmountOut`.\n- Add `require(amntin > 0, \"invalid quote\");`.\n- Preferably compute and store stake/order amounts from the actual received deposit amount (balance-before/after) and/or redesign so stake packages are defined in depositToken units rather than an oracle-quoted internal unit.\n- If quoting remains necessary, refactor `estimateAmountOut` to accept `uint256` safely and use checked conversions.", "focus_areas": ["input_validation", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:21:34.627677+00:00", "code_visible": false}}
{"id": "rpp", "name": "RPP", "chain_id": 56, "block_number": 43752881, "target_contract": "0x7d1a69302D2A94620d5185f2d80e065454a35751", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-11/RPP_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "RPP_exp.sol", "evm_version": null, "exploit_timestamp": 1730838656, "native_token_price_usd": 592.67, "tags": [], "lost_amount_usd": 14100.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Token burns directly from the UniswapV2 pair address and calls sync(), breaking AMM reserve invariants", "severity": "critical", "content": "The contract implements an \u201cLP burn\u201d mechanism by burning the token balance held at the UniswapV2 pair address (via `_recordBurn(uniswapV2Pair, amountToBurn)` in `_burnLpsToken()` / `autoLiquidityPairTokens()`) and then calling `IUniswapV2Pair(uniswapV2Pair).sync()`. This does not burn LP tokens; it destroys one side of the pool\u2019s reserves by changing the pair\u2019s ERC20 token balance outside the pair\u2019s `swap/mint/burn` flows. As a result, the pair\u2019s stored reserves become temporarily inconsistent with actual balances, and `sync()` forcibly updates reserves to the manipulated balances. Because this burn+sync is executed during user-driven paths (notably during sells in `_transfer()` and in `_sell()`), any external actor can repeatedly trigger this mechanism through normal trading, causing deterministic, one-sided reserve reductions and abrupt price shifts. This breaks UniswapV2 invariant assumptions and enables economically profitable price manipulation/arbitrage against the pool, draining the quote asset and/or causing severe losses to traders and LPs. Even without an attacker, the mechanism introduces extreme, externally triggerable volatility and can destabilize liquidity.\n", "fix_description": "Remove any logic that burns/transfers this token from the pair address and remove token-side calls to `pair.sync()`. If the intent is LP burning, only burn/lock actual LP tokens that the contract owns (e.g., transfer LP tokens held by the contract to a dead address), without modifying the underlying token reserves. Alternatively, implement liquidity/fee mechanics via standard router addLiquidity and fee collection from transfers (contract/user balances), never by altering the pair\u2019s balance directly.", "focus_areas": ["economic_attacks", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:21:46.821754+00:00", "code_visible": true}}
{"id": "btc24h", "name": "BTC24H", "chain_id": 137, "block_number": 65560668, "target_contract": "0x968e1c984A431F3D0299563F15d48C395f70F719", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-12/BTC24H_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "BTC24H_exp.sol", "evm_version": null, "exploit_timestamp": 1734370278, "native_token_price_usd": 0.57, "tags": [], "lost_amount_usd": 85700.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "claim() transfers locked tokens to msg.sender without beneficiary/owner authorization", "severity": "critical", "content": "The contract implements a lock-and-claim flow but does not bind the withdrawal right to any specific beneficiary (or to the depositor). The stored state (`claims`) contains only `amount`, `releaseDate`, and `claimed`, and `claim()` only enforces a time check (`block.timestamp >= claims.releaseDate`) and that the claim has not already been marked as claimed. There is no access control (e.g., `onlyOwner`) and no beneficiary address stored/validated. As a result, once the release time is reached, any external account can call `claim()` and the contract will transfer `claims.amount` to the caller (`token.safeTransfer(msg.sender, claimAmount)`). This creates a first-come-first-served withdrawal model where the intended recipient has no exclusive right to the locked funds, enabling direct loss of the entire locked token amount as soon as it becomes claimable.", "fix_description": "Bind claims to an authorized recipient and enforce it in `claim()`. For example: add `address beneficiary` to the `Claim` struct (or a dedicated storage variable), set it during `deposit()` (or constructor), and require `msg.sender == beneficiary` in `claim()`. Alternatively, make `claim()` `onlyOwner` and always transfer to `owner` rather than `msg.sender`.", "focus_areas": ["access_control", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:21:09.596558+00:00", "code_visible": true}}
{"id": "bizness", "name": "Bizness", "chain_id": 8453, "block_number": 24282213, "target_contract": "0x80b9C9C883e376c4aA43d72413aB1Bd6A64A0654", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-12/Bizness_exp.sol", "defihacklabs_vuln_type": "Reentrancy", "exploit_file": "Bizness_exp.sol", "evm_version": null, "exploit_timestamp": 1735353775, "native_token_price_usd": 3397.86, "tags": [], "lost_amount_usd": 15700.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "External ETH fee/refund calls occur before critical state updates (reentrancy)", "severity": "critical", "content": "`createLock()` and `splitLock()` both invoke `_feeHandler()`, which performs external ETH transfers via low-level `call` to `config.treasury()` and (when `msg.value > fee`) refunds the excess back to `_msgSender()`. These external interactions are executed while the contract is in an intermediate state: in `splitLock()` specifically, `_feeHandler()` is called *before* the original lock\u2019s `amount` is reduced and before the split lock is created. Because the refund is sent to the caller, if the caller is a contract its `receive()`/`fallback()` can execute and reenter the Locker during the in-flight `splitLock()` transaction. The contract has no `ReentrancyGuard`, and `withdrawLock()` only relies on beneficiary/time checks; therefore, reentrancy can allow actions (including withdrawal) to observe and act on stale lock accounting (e.g., the pre-split amount) and can break the intended one-time-claim invariants. This can result in unauthorized/premature withdrawals and effective double-claims against the same locked balance, draining assets held by the locker.", "fix_description": "Apply Checks-Effects-Interactions and add reentrancy protection. Concretely: (1) inherit `ReentrancyGuardUpgradeable`, call `__ReentrancyGuard_init()` in `initialize()`, and mark at least `splitLock()`, `createLock()`, and `withdrawLock()` as `nonReentrant`. (2) In `splitLock()`, perform all state updates (decrement original lock amount, create/store new lock, increment `lockId`) before any ETH transfers; ideally remove refunds by requiring exact fee payment: `uint256 fee = _fee(_whitelist); require(msg.value == fee, \"fee mismatch\");` and only transfer `fee` to treasury.", "focus_areas": ["reentrancy", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:21:45.065035+00:00", "code_visible": true}}
{"id": "moonhacker", "name": "Moonhacker", "chain_id": 10, "block_number": 129697250, "target_contract": "0xD9B45e2c389b6Ad55dD3631AbC1de6F2D2229847", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-12/Moonhacker_exp.sol", "defihacklabs_vuln_type": "improper input validation", "exploit_file": "Moonhacker_exp.sol", "evm_version": null, "exploit_timestamp": 1734993279, "native_token_price_usd": 3491.08, "tags": [], "lost_amount_usd": 318900.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Flash-loan callback executeOperation() lacks Aave Pool/initiator authentication", "severity": "critical", "content": "The contract\u2019s Aave V3 flash-loan receiver callback `executeOperation(...)` is declared `external` but does not enforce the standard trust assumptions for this callback. In particular, it does not verify that `msg.sender` is the canonical Aave Pool contract, nor that `initiator` is this contract (or another explicitly trusted initiator). As a result, any external address can call `executeOperation` directly with attacker-chosen arguments and parameters, causing the contract to execute sensitive logic intended only to run during an authentic flash-loan lifecycle.\n\nThis is especially dangerous because `executeOperation` performs privileged asset actions based on decoded `params`, including ERC20 approvals and calls into third-party contracts. Without caller/initiator validation, `executeOperation` becomes a public entrypoint that can be used to induce approvals from the contract to arbitrary spenders and trigger external protocol interactions under attacker-controlled inputs. If the contract holds any ERC20 balances (e.g., operational funds, proceeds, mistakenly sent tokens, or residuals), an attacker can leverage these approvals/calls to exfiltrate funds or otherwise manipulate the contract\u2019s asset state.\n\nThis violates the Aave flash-loan receiver security model: the callback must be callable only by the Pool as part of the flash-loan execution.", "fix_description": "Add strict authentication at the top of `executeOperation`:\n- `require(msg.sender == address(POOL), \"only Aave Pool\");`\n- `require(initiator == address(this), \"invalid initiator\");`\nOptionally also validate `token`/decoded params against an allowlist of supported assets/markets before executing any approvals or external calls.", "focus_areas": ["access_control", "execution_flow"], "auditable": true}, {"title": "Unvalidated mToken/spender address from calldata is used for ERC20 approvals and external calls", "severity": "critical", "content": "Inside `executeOperation`, the contract decodes user-controlled `params` into an `mToken` address and then uses it directly as (a) the spender for `IERC20(token).approve(mToken, ...)` and (b) the target for subsequent external calls (`IMToken(mToken).mint/borrow/repayBorrow/redeem`). There is no validation that `mToken` is a legitimate, expected market contract for the given `token`, nor that it is trusted.\n\nThis design creates an \u201carbitrary approval\u201d primitive: if `mToken` is attacker-controlled (or simply incorrect/misconfigured), the contract will grant that address an allowance over its ERC20 balance. Any approved spender can then pull tokens from the contract via `transferFrom`, draining any funds held. The external call sequence further increases risk because a malicious `mToken` contract can return arbitrary values, perform callbacks, or otherwise influence control flow once invoked.\n\nEven if `executeOperation` is properly restricted to Aave, leaving spender/target selection to calldata is still high risk: any future bug, misconfiguration, or unexpected flash-loan path could result in persistent, exploitable allowances to an unintended address.", "fix_description": "Do not accept `mToken` from untrusted calldata. Derive it from a trusted mapping/allowlist (e.g., `token => mToken`) and enforce `require(mToken == expectedMTokenFor(token))` before any approval/call. Additionally, minimize and sanitize allowances (reset to 0 then set exact amount; revoke after use where feasible) using SafeERC20 patterns.", "focus_areas": ["input_validation", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:22:14.951890+00:00", "code_visible": true}}
{"id": "slurpycoin", "name": "SlurpyCoin", "chain_id": 56, "block_number": 44990634, "target_contract": "0x72c114A1A4abC65BE2Be3E356eEde296Dbb8ba4c", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-12/SlurpyCoin_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "SlurpyCoin_exp.sol", "evm_version": null, "exploit_timestamp": 1734552916, "native_token_price_usd": 665.02, "tags": [], "lost_amount_usd": 3000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Auto buyback is externally triggerable and executes swaps with amountOutMin = 0 using the contract\u2019s entire ETH balance", "severity": "critical", "content": "The token implements an automated sell/buyback mechanism that is executed from within `_transfer()` when `balanceOf(address(this)) >= numTokensToSell` and `swapAndLiquifyEnabled` is enabled. Because `_transfer()` is invoked for normal transfers, any external account can trigger this mechanism simply by sending small transfers once the threshold is met. The swap logic has no meaningful execution constraints: in the buyback branch, the contract sets `bal = address(this).balance` and calls `swapExactETHForTokens{value: bal}(0, path, owner(), block.timestamp)`, spending *all* ETH held by the contract with `amountOutMin = 0` (no slippage protection). Similarly, the sell path uses `swapExactTokensForETHSupportingFeeOnTransferTokens(..., 0, ...)`.\n\nThis design makes the contract\u2019s swaps economically unsafe: execution depends on the AMM\u2019s spot price at the moment the transfer occurs, with no bounds and no oracle/TWAP validation. As a result, the contract can be forced to trade at an unfavorable price, allowing value to be extracted from the contract\u2019s accumulated ETH during the buyback, and generally causing severe loss of funds/value for holders.\n", "fix_description": "Harden and restrict the swap trigger and enforce slippage/price protections:\n- Restrict auto-execution to specific flows (e.g., only on sells: `require(to == uniswapV2Pair)`), and/or gate execution behind `onlyOwner`/keeper.\n- Do not spend `address(this).balance` in one call; cap ETH spend per buyback and add cooldowns.\n- Replace `amountOutMin = 0` with a computed minimum output using `router.getAmountsOut()` and a configurable max slippage (or enforce TWAP/oracle-based bounds). Revert when price impact exceeds tolerance.\n- Optionally require a minimum liquidity / reserve check before executing.\n", "focus_areas": ["economic_attacks", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:22:00.561016+00:00", "code_visible": false}}
{"id": "odos", "name": "ODOS", "chain_id": 8453, "block_number": 25431000, "target_contract": "0xB6333E994Fd02a9255E794C177EfBDEB1FE779C7", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-01/ODOS_exp.sol", "defihacklabs_vuln_type": "invalid-signature-verification", "exploit_file": "ODOS_exp.sol", "evm_version": null, "exploit_timestamp": 1737651349, "native_token_price_usd": 3309.74, "tags": [], "lost_amount_usd": 50000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Public signature-validation helper performs attacker-controlled external calls when parsing ERC-6492 signatures", "severity": "critical", "content": "The router inherits `UniversalSigValidator` and exposes signature-validation entry points that accept an `allowSideEffects` flag (e.g., `isValidSigImpl(..., bool allowSideEffects)` and `isValidSigWithSideEffects(...)`). When `allowSideEffects == true` and the provided signature is ERC-6492 formatted, the validator decodes `(create2Factory, factoryCalldata, sigToValidate)` and, if `_signer` currently has no code, executes `create2Factory.call(factoryCalldata)` before completing any meaningful signature verification.\n\nBecause `create2Factory` and `factoryCalldata` are fully user-controlled and the call is executed with the router as `msg.sender`, this turns a \u201csignature check\u201d helper into a generic arbitrary external call primitive from the router. Any assets held by the router (ERC20 balances, approvals, ETH via payable flows) become exposable: an attacker can make the router call token contracts, approval targets, or other protocols to move funds or change critical state. The impact is total loss of all router-held assets and arbitrary state-changing interactions, triggered by any external caller who can reach these helper functions.\n\nThis behavior is especially dangerous because it occurs during validation and can happen even if the signature is invalid, since the side-effecting call is executed prior to final validation success/failure.", "fix_description": "Remove side effects from on-chain signature verification and prevent public reachability:\n1) Delete/disable `isValidSigWithSideEffects` and make `isValidSigImpl` `internal` (or at least not externally callable from the router).\n2) Ensure router code paths only use a no-side-effects validator (`allowSideEffects = false`).\n3) If ERC-6492 support is required, strictly whitelist permitted deployment factory addresses and validate calldata format/selectors to only allow expected CREATE2 deployment calls; otherwise revert. Prefer `staticcall`-style validation where possible and never execute arbitrary calls during validation.", "focus_areas": ["execution_flow", "access_control"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:21:52.221635+00:00", "code_visible": false}}
{"id": "duckvader", "name": "DUCKVADER", "chain_id": 8453, "block_number": 27445834, "target_contract": "0xaa8f35183478B8EcEd5619521Ac3Eb3886E98c56", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/DUCKVADER_exp.sol", "defihacklabs_vuln_type": "Free Mint Bug", "exploit_file": "DUCKVADER_exp.sol", "evm_version": null, "exploit_timestamp": 1741681017, "native_token_price_usd": 1922.98, "tags": [], "lost_amount_usd": 9600.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Shadowed `_balances` mapping breaks ERC20 accounting and invalidates `buyTokens()` eligibility logic", "severity": "critical", "content": "The contract declares `mapping(address => uint256) public _balances;` in `DUCKVADER`, which shadows OpenZeppelin ERC20\u2019s internal `_balances` storage. This creates two independent \u201cbalance ledgers\u201d: (1) the real ERC20 balances used by `balanceOf()`, `transfer()`, `transferFrom()`, `_transfer()`, and `_mint()`, and (2) the DUCKVADER `_balances` mapping used only by `buyTokens()`.\n\n`buyTokens(uint256 amount)` makes minting/eligibility decisions based on the shadowed mapping (e.g., `if (_balances[msg.sender] == 0) { _mint(...) }`) and then updates only the shadowed mapping using `newBalance += amount`. Because the shadow mapping is not the canonical ERC20 balance, the contract\u2019s mint gating can be bypassed and/or become permanently inconsistent with the true transferable ERC20 balance. In particular, callers can satisfy the \u201cfirst-time buyer\u201d condition repeatedly if the shadow mapping is never incremented (e.g., `amount == 0`), while still receiving real ERC20 tokens via `_mint()` in the inherited ERC20 storage. This enables unpriced or repeated minting that can be dumped against liquidity pools, draining paired assets and collapsing the token economy.", "fix_description": "Remove the shadowing mapping and use a dedicated, unambiguous state variable for eligibility tracking.\n- Delete `mapping(address => uint256) public _balances;` from `DUCKVADER`.\n- In `buyTokens()`, do not reference `_balances`; use `balanceOf(msg.sender)` only if you truly want a balance-based condition, or better track a separate `mapping(address => bool) public claimed;` for one-time mints.\n- Ensure `buyTokens()` increments the correct state for eligibility and that minting uses `_mint()` with proper supply/accounting.\n- Add input validation such as `require(amount > 0, \"amount=0\");` if zero-amount calls are not meaningful.", "focus_areas": ["semantic_verification", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:22:27.698362+00:00", "code_visible": true}}
{"id": "leveragesir", "name": "LeverageSIR", "chain_id": 1, "block_number": 22157899, "target_contract": "0xB91AE2c8365FD45030abA84a4666C4dB074E53E7", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-03/LeverageSIR_exp.sol", "defihacklabs_vuln_type": "Storage SLOT1 collision", "exploit_file": "LeverageSIR_exp.sol", "evm_version": null, "exploit_timestamp": 1743315671, "native_token_price_usd": 1807.48, "tags": [], "lost_amount_usd": 353800.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Uniswap V3 swap callback lacks strict pool authentication and trusts unvalidated callback data", "severity": "critical", "content": "The contract exposes `uniswapV3SwapCallback(int256,int256,bytes)` in a way that does not strictly authenticate that the caller is the canonical Uniswap V3 pool corresponding to the swap being settled. Instead, the callback logic relies on attacker-influenced inputs (directly or indirectly via decoded `data`) to determine which token to pay, who the payer is, and/or the payment recipient. In Uniswap V3, the callback is a privileged settlement step: the pool calls the callee back and expects the callee to transfer the exact owed amount(s) of `token0`/`token1` to the pool (`msg.sender`). If the callback can be invoked by an arbitrary address, or if the token/recipient/payer are not strictly bound to `msg.sender` and the actual deltas, an attacker can call the callback directly (or via a fake pool) and induce transfers of arbitrary ERC20s held by the vault under the guise of \u201cswap payment\u201d, even when no legitimate vault-initiated swap occurred. This enables direct and repeatable draining of vault-held assets.", "fix_description": "In `uniswapV3SwapCallback`, derive the expected pool address from a trusted Uniswap V3 factory using `(token0, token1, fee)` and require `msg.sender == expectedPool`. Do not accept token addresses/recipients from untrusted `data`; instead, read `token0/token1` (and fee if needed) from the computed pool/immutables. Validate `amount0Delta/amount1Delta` and transfer only the exact owed token(s) to `msg.sender` (the pool), from a trusted payer (e.g., `address(this)` or an explicitly authorized payer).", "focus_areas": ["access_control", "asset_management"], "auditable": true}, {"title": "Callback authorization relies on mutable attacker-influenceable state (including transient storage) rather than immutable pool derivation", "severity": "high", "content": "The callback authorization mechanism appears to be based on a value stored in storage/transient storage (e.g., a \u201ccurrent pool/current caller\u201d slot) that is set during other execution paths and then checked inside `uniswapV3SwapCallback`. Because this authorization value is not derived from immutable Uniswap V3 pool computation and can be influenced by user-controlled inputs (e.g., amounts/parameters written into the slot), an attacker can manipulate it to match an address they control. This is particularly dangerous when the code effectively treats an attacker-controlled 160-bit value as an authorized caller address, because an attacker can deploy a contract at a chosen address (e.g., via CREATE2) and satisfy the check. Once the check is bypassed, the attacker gains access to the callback\u2019s privileged token-transfer path and can force the vault to pay out assets as if settling a swap. Authorization based on mutable state is insufficient for Uniswap callbacks; it must be anchored to the factory-derived pool address and the actual swap context.", "fix_description": "Remove/avoid any authorization that depends on mutable or attacker-influenced storage/tstore values (and never cast user-controlled numeric inputs into addresses for authorization). Authenticate the callback exclusively by verifying `msg.sender` equals the factory-derived pool for the intended `(token0, token1, fee)` and (optionally) verifying pool immutables. If transient state is necessary, store a swap-context hash/nonce set only by trusted internal swap initiation, but still require `msg.sender` is the computed pool.", "focus_areas": ["access_control", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:22:29.345474+00:00", "code_visible": false}}
{"id": "impermaxv", "name": "ImpermaxV3", "chain_id": 8453, "block_number": 29437438, "target_contract": "0x5d93f216f17c225a8B5fFA34e74B7133436281eE", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-04/ImpermaxV3_exp.sol", "defihacklabs_vuln_type": "FlashLoan Price Oracle Manipulation", "exploit_file": "ImpermaxV3_exp.sol", "evm_version": null, "exploit_timestamp": 1745664225, "native_token_price_usd": 1821.45, "tags": [], "lost_amount_usd": 300000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "restructureDebt() reduces borrower principal/totalBorrows without enforcing receipt of underlying repayment", "severity": "critical", "content": "ImpermaxV3Borrowable.restructureDebt() performs a debt write-down by computing a repayAmount and calling _updateBorrow(tokenId, 0, repayAmount), which decreases the borrower\u2019s principal and decreases global totalBorrows. However, unlike other debt-decreasing paths (e.g., liquidate/repay flows), restructureDebt() never enforces that the Borrowable contract actually received repayAmount of underlying tokens. There is no transferFrom(), no requirement that the caller pre-transferred funds, and no invariant check comparing balanceOf(underlying) against the internal totalBalance accounting.\n\nThis creates \u201cphantom repayment\u201d: the protocol\u2019s accounting treats debt as repaid even though no assets were added to the pool. The immediate consequence is a solvency break: utilization and borrow limits can be artificially improved and the borrower\u2019s debt reduced on paper, enabling additional borrows/redemptions that drain real underlying liquidity from lenders. If the surrounding collateral logic permits restructureDebt() to be invoked under attacker-influenced conditions, the pool can be drained without any corresponding inflow of underlying.\n\nIn short, restructureDebt() violates the fundamental invariant that any reduction in totalBorrows must be backed by an equal increase in pool assets (or an explicitly accounted loss).", "fix_description": "Require actual underlying repayment before reducing borrows in restructureDebt(): either (a) pull funds inside restructureDebt() via IERC20(underlying).transferFrom(payer, address(this), repayAmount) and then call _updateBorrow, or (b) require the collateral contract transfers repayAmount in first and verify via a balance-delta check:\n- uint256 bal = IERC20(underlying).balanceOf(address(this));\n- require(bal - totalBalance >= repayAmount, \"INSUFFICIENT_ACTUAL_REPAY\");\nIf the intent is a protocol-funded write-down, track it as an explicit loss/reserve mechanism and adjust lender exchange rate accordingly instead of silently reducing totalBorrows.", "focus_areas": ["asset_management", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:22:48.356584+00:00", "code_visible": false}}
{"id": "laundromat", "name": "Laundromat", "chain_id": 1, "block_number": 22222686, "target_contract": "0x934cbbE5377358e6712b5f041D90313d935C501C", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-04/Laundromat_exp.sol", "defihacklabs_vuln_type": "Logic Flaw", "exploit_file": "Laundromat_exp.sol", "evm_version": null, "exploit_timestamp": 1744097291, "native_token_price_usd": 1472.15, "tags": [], "lost_amount_usd": 1500.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "deposit() does not enforce exact payment amount (commented-out msg.value check)", "severity": "critical", "content": "The contract\u2019s accounting assumes each participant deposits exactly `payment` ETH, and later withdrawals pay out exactly `payment` ETH per successful withdrawal. However, `deposit(uint _pubkey1, uint _pubkey2) payable` has the only enforcement of this invariant commented out (`//if(msg.value != payment) throw;`). As a result, anyone can register a participant slot while sending 0 ETH (or any arbitrary amount), yet still increment `gotParticipants` and populate `pubkeys1/pubkeys2`. Once `gotParticipants >= participants`, the withdrawal flow becomes available.\n\nCritically, `withdrawFinal()` unconditionally executes `safeSend(withdraw.sender, payment)` upon passing its signature/ring checks, with no linkage to whether that `withdraw.sender` ever deposited `payment`, and no mechanism ensuring that total payouts are backed by total deposits for the round. Therefore, if the contract has any ETH balance (e.g., from honest deposits or leftover funds), an attacker can register participants without funding the pool and then complete the withdrawal flow to receive `payment` funded by other users\u2019 deposits. This breaks the protocol\u2019s core economic invariant and can lead to complete loss of funds held by the contract.", "fix_description": "Reinstate strict payment enforcement in `deposit`:\n- `require(msg.value == payment, \"wrong payment\");`\nAdditionally harden accounting by tracking deposits per participant (address or commitment) and gating withdrawals on proven contribution, and/or enforce that a round cannot pay out more than the round\u2019s total deposits.", "focus_areas": ["business_logic", "asset_management"], "auditable": true}, {"title": "deposit() allows non-unique/unbound participant registration (no ownership or uniqueness checks for pubkeys/participants)", "severity": "high", "content": "The protocol relies on a participant set that represents distinct, independently funded users. However, `deposit()` only checks `gotParticipants < participants` and then appends the provided pubkeys to `pubkeys1/pubkeys2`. There is no uniqueness constraint (duplicate pubkeys can be reused), no binding between a participant slot and `msg.sender`, and no proof that the depositor controls the submitted pubkeys.\n\nThis enables a single entity to register multiple (or all) participant slots (Sybil injection) using attacker-chosen keys, potentially even repeating the same keypair. As a result, the contract can reach `gotParticipants == participants` without representing a genuine multi-party set, allowing one actor to unilaterally progress the system into the withdrawal phase and satisfy the \u201cparticipants filled\u201d precondition without coordination. Combined with the missing deposit-payment enforcement, this makes it straightforward to create fully attacker-controlled rounds and extract payouts that are not backed by attacker deposits, effectively turning any existing contract balance into a target.\n\nEven if the cryptographic checks are correct, the lack of participant ownership/uniqueness undermines the intended security model and enables abuse of the protocol\u2019s economic assumptions.", "fix_description": "Bind deposits to unique funded participants:\n- Enforce one slot per address: `require(!isParticipant[msg.sender]); isParticipant[msg.sender]=true;`\n- Enforce unique pubkeys: `require(!pubkeyUsed[keccak256(pubkey1,pubkey2)]); pubkeyUsed[...] = true;`\n- Optionally require a signature at deposit time proving control of the submitted pubkey.\nUse these together with `require(msg.value == payment)` to ensure only distinct, paid participants can fill a round.", "focus_areas": ["business_logic", "input_validation"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:03.949706+00:00", "code_visible": true}}
{"id": "corkprotocol", "name": "Corkprotocol", "chain_id": 1, "block_number": 22581019, "target_contract": "0xCCd90F6435dd78C4ECCED1FA4db0D7242548a2a9", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-05/Corkprotocol_exp.sol", "defihacklabs_vuln_type": "Access Control", "exploit_file": "Corkprotocol_exp.sol", "evm_version": null, "exploit_timestamp": 1748432387, "native_token_price_usd": 2682.1, "tags": [], "lost_amount_usd": 12000000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "CorkConfig.initializeModuleCore() lacks access control (permissionless market initialization)", "severity": "critical", "content": "CorkConfig.initializeModuleCore(...) is externally callable and is not restricted by onlyManager/onlyRole. This function is a control-plane entrypoint that forwards directly into ModuleCore.initializeModuleCore(...) and then applies protocol configuration for the derived market Id (e.g., vault NAV threshold). Because CorkConfig is the authorized caller from ModuleCore\u2019s perspective, leaving this function permissionless effectively makes market listing/initialization a public operation.\n\nThis breaks the protocol\u2019s governance boundary: any account can create arbitrary markets with attacker-chosen parameters (PA, RA, initialArp, expiryInterval, exchangeRateProvider). In particular, allowing an untrusted exchangeRateProvider enables an attacker to register a market whose pricing/ratio inputs are controlled by attacker code, which can corrupt any downstream accounting or mint/burn/return math that relies on that provider. Even if no immediate drain occurs in this function, it enables creation of \u201clegitimate-looking\u201d markets that other components may treat as trusted, opening direct paths to value extraction and/or irrecoverable state pollution.\n\nMarket initialization should be treated as a privileged governance action with strict validation of inputs (especially price/rate providers).", "fix_description": "Add governance/manager-only gating to CorkConfig.initializeModuleCore and restrict/validate exchangeRateProvider.\n\n- Add `onlyManager` (and optionally `whenNotPaused`) to `initializeModuleCore`.\n- Enforce `exchangeRateProvider` is either the canonical provider or an allowlisted provider (`approvedProviders[provider] == true`).\n- Optionally validate PA/RA are allowlisted assets and apply sensible bounds to initialArp/expiryInterval.\n", "focus_areas": ["access_control", "oracle_manipulation"], "auditable": true}, {"title": "CorkConfig.issueNewDs() is callable by anyone (missing role check on issuance/epoch progression)", "severity": "high", "content": "CorkConfig.issueNewDs(Id id, uint256 ammLiquidationDeadline) is publicly callable and only gated by whenNotPaused. The function advances core protocol lifecycle state by invoking ModuleCore.issueNewDs(...), which can deploy/initialize new issuance instruments (e.g., CT/DS), roll epochs, and update connected routing/AMM configuration.\n\nBecause this action is part of protocol operations/governance (timed issuances, rollovers, and configuration updates), making it permissionless allows any external account to force issuance at arbitrary times and for arbitrary ids that exist in state. This can push markets into unexpected or unsafe states, bypass intended administrative sequencing, and interact badly with markets initialized with untrusted parameters. Even without a direct drain in this function itself, it materially expands the attack surface by letting an attacker drive the protocol into issuance states needed to exploit other weaknesses, and it enables griefing/DoS by repeatedly triggering rollovers or creating unplanned asset deployments.\n\nIssuance should be controlled by a trusted operator (governance/manager) and validated against timing and configuration invariants.", "fix_description": "Restrict `issueNewDs` to governance/manager and add sanity checks.\n\n- Add `onlyManager` to `issueNewDs`.\n- Validate the `id` corresponds to an approved/initialized market.\n- Enforce timing constraints (e.g., cannot issue before the scheduled window) and bounds on `ammLiquidationDeadline`.\n", "focus_areas": ["access_control", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:13.316812+00:00", "code_visible": true}}
{"id": "unwarp", "name": "Unwarp", "chain_id": 8453, "block_number": 30210273, "target_contract": "0x8bEfC1d90d03011a7d0b35B3a00eC50f8E014802", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-05/Unwarp_exp.sol", "defihacklabs_vuln_type": "lack-of-access-control", "exploit_file": "Unwarp_exp.sol", "evm_version": null, "exploit_timestamp": 1747209893, "native_token_price_usd": 2610.07, "tags": [], "lost_amount_usd": 9000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "WETH unwrap/ETH payout helper is externally callable without authorization or reward accounting", "severity": "critical", "content": "The contract includes a helper intended to be used as part of the reward payout flow: converting rewardToken (WETH) held by the contract into native ETH via `WETH.withdraw(amount)` and then forwarding ETH to a recipient address. However, this helper is exposed as an externally callable function and is not protected by any access control or internal accounting constraints. There is no requirement that the caller is claiming their own rewards, no validation that the requested `amount` corresponds to the caller\u2019s accrued/claimable rewards, and no restriction on the `to` address. As a result, any account can invoke the unwrap-and-send path with an arbitrary `amount` and recipient and force the contract to unwrap WETH from the contract\u2019s own balance and transfer ETH out. This breaks the fundamental assumption that only earned rewards can be paid, and enables complete draining of any WETH reward reserves held by the contract.\n\nBecause this function performs asset conversion and an ETH transfer based on user-supplied parameters, it must not be callable without strict authorization and must not accept arbitrary amounts/recipients that are not derived from internal reward state.", "fix_description": "Make the unwrap helper non-external and fully driven by internal accounting:\n- Change `unwrapWETH(uint256 amount, address to)` to `internal` (or `private`) and only call it from `claimReward()`.\n- In `claimReward()`, compute `amount` from contract state (earned/claimable) and set `to = msg.sender` (do not accept user-supplied `amount/to`).\n- If it must remain external for operational reasons, add strict gating (e.g., `onlyOwner`/whitelist) AND enforce `to == msg.sender` and `amount <= claimable(msg.sender)`, with state updates performed before any external calls.", "focus_areas": ["access_control", "asset_management"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:22:56.376817+00:00", "code_visible": false}}
{"id": "superrare", "name": "SuperRare", "chain_id": 1, "block_number": 23016422, "target_contract": "0x3f4D749675B3e48bCCd932033808a7079328Eb48", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-07/SuperRare_exp.sol", "defihacklabs_vuln_type": "Access Control", "exploit_file": "SuperRare_exp.sol", "evm_version": null, "exploit_timestamp": 1753690919, "native_token_price_usd": 3798.95, "tags": [], "lost_amount_usd": 730000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "updateMerkleRoot() authorizes a hardcoded EOA in addition to owner()", "severity": "critical", "content": "The function responsible for updating the Merkle root (which fully defines claim eligibility and amounts) is not exclusively restricted to the contract owner. Instead, it allows calls from either `owner()` or a hardcoded external address (`0xc2F394a45e994bc81EfF678bDE9172e10f7c8ddc`). This creates an immutable privileged backdoor that can replace `currentClaimRoot` and advance `currentRound` at any time.\n\nBecause `claim()` relies solely on `currentClaimRoot` to authorize payouts, any entity controlling this hardcoded key can arbitrarily rewrite the distribution set to include themselves for any amount and repeatedly advance rounds, enabling unauthorized reward extraction and/or denial-of-service against legitimate claimants. Since the privileged address is hardcoded, it cannot be rotated, revoked, or secured through the normal ownership/role management flow, and the protocol remains permanently exposed to compromise/misconfiguration of that key for the lifetime of the deployment (absent an upgrade).", "fix_description": "Remove the hardcoded address and enforce standard access control.\n\nExample:\n- Replace the authorization check with `onlyOwner`.\n- If a second operator is required, implement a configurable role (e.g., `AccessControlUpgradeable` with `MERKLE_ADMIN_ROLE`) or an owner-settable `merkleRootUpdater` address that can be rotated/revoked.\n\n```solidity\nfunction updateMerkleRoot(bytes32 newRoot) external onlyOwner {\n    if (newRoot == bytes32(0)) revert EmptyMerkleRoot();\n    currentClaimRoot = newRoot;\n    currentRound++;\n    emit NewClaimRootAdded(newRoot, currentRound, block.timestamp);\n}\n```", "focus_areas": ["access_control", "upgradeable_contracts"], "auditable": true}, {"title": "Merkle verification permits empty proofs, making a single-leaf root sufficient for arbitrary claims if the root can be set", "severity": "high", "content": "The Merkle claim verification accepts proofs of length 0 and computes the leaf as `keccak256(abi.encodePacked(recipient, value))`. With OpenZeppelin `MerkleProof.verify`, an empty proof returns true when `root == leaf`. As a result, if an attacker (or misconfigured privileged party) can set `currentClaimRoot`, they can construct a \u201ctree\u201d consisting of a single leaf equal to `keccak256(recipient, value)` and successfully pass verification using an empty proof.\n\nThis behavior is inherent to Merkle proof verification, but the contract design does not include any additional binding (e.g., to `currentRound`, distribution id, or minimum tree depth) to prevent a root update from becoming an authorization for an arbitrary one-off claim. Therefore, root update authority becomes equivalent to direct authorization of arbitrary claims, and any weakness in root governance immediately translates into loss of funds from the reward source.", "fix_description": "Primary mitigation is to strictly secure `updateMerkleRoot()` (see critical finding). Add defense-in-depth to reduce blast radius if root rotation is ever compromised:\n- Bind leaves to the round and/or a domain separator: `leaf = keccak256(abi.encode(currentRound, recipient, value))` (ensure off-chain tree generation matches).\n- Optionally require `proof.length > 0` if single-leaf distributions are not valid in your system.\n- Consider cumulative-amount accounting (claimed-to-date) instead of per-round booleans to reduce repeated-drain risk across manipulated rounds.", "focus_areas": ["business_logic", "semantic_verification"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:11.817229+00:00", "code_visible": true}}
{"id": "wetc_token", "name": "WETC Token", "chain_id": 56, "block_number": 54333337, "target_contract": "0xE7f12B72bfD6E83c237318b89512B418e7f6d7A7", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-07/WETC_Token_exp.sol", "defihacklabs_vuln_type": "Incorrect Burn Logic", "exploit_file": "WETC_Token_exp.sol", "evm_version": null, "exploit_timestamp": 1752747885, "native_token_price_usd": 721.3, "tags": [], "lost_amount_usd": 101000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Contract uses manipulable AMM spot balances as a price oracle for stateful fee logic", "severity": "critical", "content": "The contract derives a \u201ctoken price\u201d in `getLinePrice()` directly from the Pancake/UniswapV2 pair\u2019s current token balances (`IERC20(...).balanceOf(pairAddress)`) and uses that value inside `checkDayDf()` to update `dayPercent[day]`. This is a known oracle anti-pattern: pair balances/reserves represent a spot price that can be moved arbitrarily within a single transaction by anyone interacting with the pair (e.g., through swaps or direct transfers to the pair followed by sync-like state changes). Because `checkDayDf()` writes state (setting a daily flag/percent) and is reachable from the transfer path (`_transfer() -> transferBuy/transferSell`), an attacker can force the contract to read a transient, manipulated spot price at a chosen time and persistently alter fee behavior for subsequent transfers.\n\nIn short, the contract treats an attacker-controlled, flash-manipulable on-chain spot price as a trusted input to state changes and transfer-fee logic. This enables economic manipulation of the token\u2019s fee system and downstream AMM interactions, and can be used to extract value by creating artificial pricing/fee conditions not achievable under honest market prices.", "fix_description": "Remove spot-balance pricing from the transfer path. Replace `getLinePrice()` with a manipulation-resistant oracle (e.g., UniswapV2 TWAP via cumulative prices over a minimum time window, or a reputable external oracle such as Chainlink). Ensure `checkDayDf()` uses the averaged price and is rate-limited (e.g., only update once per period) and ideally triggered by a trusted keeper/admin function rather than implicitly during `_transfer`.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}, {"title": "Whitelist branch in `_transfer` lacks early return, allowing multiple transfer paths to execute", "severity": "high", "content": "In `_transfer`, the contract attempts to bypass custom fee/liquidity logic for whitelisted addresses by executing `super._transfer(from,to,amount)` when `whiteAddress[from] == 1 || whiteAddress[to] == 1`. However, the function does not return afterward, so execution continues into subsequent branches (liquidity detection and buy/sell logic). As a result, a single call to `_transfer` can perform the whitelist transfer and then also perform additional transfers/fee accounting in the same transaction.\n\nThis breaks the expected ERC20 transfer invariant of \u201cone transfer per call\u201d and can lead to unintended token movements involving the AMM pair (or unexpected fee behavior) when either side is whitelisted. In AMM contexts, this can desynchronize reserves/balances assumptions and amplify other economic manipulation vectors by making transfers non-atomic and harder to reason about. Even without an attacker, it introduces correctness risks (unexpected double-debits/credits or reverts due to insufficient balances after the first transfer).", "fix_description": "Add an early return after the whitelist transfer:\n\n```solidity\nif (whiteAddress[from] == 1 || whiteAddress[to] == 1) {\n    super._transfer(from, to, amount);\n    return;\n}\n```\n\nOptionally refactor into a dedicated bypass modifier/internal function to ensure no later logic can run once the bypass condition is met.", "focus_areas": ["execution_flow", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:34.678362+00:00", "code_visible": true}}
{"id": "bebop_dex", "name": "Bebop dex", "chain_id": 42161, "block_number": 367586044, "target_contract": "0xbeb0b0623f66bE8cE162EbDfA2ec543A522F4ea6", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-08/Bebop_dex_exp.sol", "defihacklabs_vuln_type": "Arbitrary user input", "exploit_file": "Bebop_dex_exp.sol", "evm_version": null, "exploit_timestamp": 1754987700, "native_token_price_usd": 4589.8, "tags": [], "lost_amount_usd": 21000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Settlement executes solver-supplied arbitrary external calls without constraining spend sources or outputs", "severity": "critical", "content": "JamSettlement.settle() forwards execution to JamInteraction.runInteractions(...), which performs an untrusted, solver-provided list of low-level calls (target, calldata, and optional ETH value). The only meaningful restriction is `interaction.to != address(balanceManager)`, which does not prevent calling arbitrary third-party contracts (including ERC20 token contracts) nor does it enforce that the calls are related to the order being settled. Critically, there is no invariant that confines asset movements to the taker\u2019s declared sellTokens/sellAmounts, and no post-condition that ensures the order\u2019s buy-side constraints are actually satisfied (especially if arrays are empty or minimally specified). This effectively turns the settlement contract into a generic call router operating under the settlement contract\u2019s address context. As a result, any external contract that trusts the settlement contract (e.g., via existing ERC20 allowances granted to the settlement contract) can be abused: arbitrary token transfers may be initiated by having the settlement contract call token contracts with crafted calldata. Because interaction failures do not necessarily revert (the runner tracks a boolean), partial execution can succeed without halting, further reducing safety guarantees.\n\nImpact: unauthorized token transfers from third parties who have approved the settlement contract, and/or other unintended state changes on arbitrary targets callable by the settlement contract.", "fix_description": "Remove or strictly constrain the interaction primitive. Enforce an allowlist of permitted targets/selectors (prefer audited adapters), and explicitly disallow direct calls to token contracts. Add strict pre/post balance accounting to ensure only the taker\u2019s declared inputs are spent (bounded by sellAmounts) and only declared outputs are received meeting minimums; revert if constraints are not met. Require every interaction call to succeed (revert on failure) unless there is a well-defined, safe failure mode.", "focus_areas": ["execution_flow", "asset_management"], "auditable": true}, {"title": "Order validation skips signature checks for self-settlement, enabling signatureless access to privileged settlement execution path", "severity": "high", "content": "JamValidation.validateOrder() conditionally bypasses signature verification when `order.taker == msg.sender` and the order is not using Permit2. While intended as a convenience for users to settle their own orders, this creates an unprotected entry path into the settlement flow where the caller can submit arbitrary order data without any cryptographic authorization. Combined with the settlement\u2019s ability to execute solver-provided interactions, the \u201cno-signature\u201d path grants any caller access to a powerful execution context (calls performed as the settlement contract) without proving intent for the specific payload being executed. Additionally, if the protocol permits orders with empty or weakly constrained fields (e.g., empty buyTokens/sellTokens arrays or missing enforceable limits), this bypass can effectively disable the core authorization model and allow settlement to be invoked for side effects unrelated to any real user order.\n\nImpact: attackers can invoke settlement without a valid user signature and leverage privileged execution (including interactions) in ways not authorized by any off-chain order signing.", "fix_description": "Do not allow signatureless settlement to execute arbitrary interactions. Require a valid signature (or validated Permit2 witness) even when `order.taker == msg.sender`, or introduce a separate \u201cself-settle\u201d function that forbids interactions and enforces strict non-empty sell/buy arrays with invariant checks. At minimum, gate interaction execution behind successful signature/Permit2 validation and revert on orders with empty/invalid constraint arrays.", "focus_areas": ["access_control", "semantic_verification"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:15.836807+00:00", "code_visible": false}}
{"id": "evervaluecoin", "name": "EverValueCoin", "chain_id": 42161, "block_number": 373990723, "target_contract": "0x03339ECAE41bc162DAcAe5c2A275C8f64D6c80A0", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-08/EverValueCoin_exp.sol", "defihacklabs_vuln_type": "Arbitrage", "exploit_file": "EverValueCoin_exp.sol", "evm_version": null, "exploit_timestamp": 1756586544, "native_token_price_usd": 4392.43, "tags": [], "lost_amount_usd": 100000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Order settlement pays takers from global contract balances instead of debiting the matched maker escrow (unbacked/insolvent order execution)", "severity": "critical", "content": "The matching/settlement logic does not enforce that each executed trade is backed by the specific maker\u2019s escrow for the matched order. While makers transfer assets into the contract when creating orders, `fillOrder()` / `partiallyFillOrder()` settle by (1) pulling the taker\u2019s send token via `safeTransferFrom`, then (2) paying the taker\u2019s receive token via `safeTransfer` directly from the contract\u2019s current token balance, and finally (3) crediting the maker in `traderBalances`.\n\nThis design implicitly assumes the contract always holds enough of the taker-receive token at execution time and that such balances correspond to the matched maker\u2019s locked funds. However, there is no per-order reserved accounting/invariant that links the taker payout to the matched order\u2019s remaining escrow. As a result, any \u201cfree\u201d inventory of a token held by the contract (from other users\u2019 deposits, leftover funds, fees, or unrelated pairs) can be used to satisfy payouts, allowing execution to drain pooled balances and create insolvency where internal liabilities exceed actual token holdings.\n\nImpact: arbitrary depletion of contract-held token balances and/or inability for honest users to withdraw/settle due to insolvency once balances are drained.", "fix_description": "Make settlement strictly order-collateralized:\n- Track escrow remaining per order (e.g., `order.escrowRemaining`) and/or reserved totals per token/pair.\n- On fill/partial fill, compute the maker-deliver amount and *debit the matched order\u2019s escrow* (and/or reserved totals) before transferring to the taker.\n- Require `makerEscrowRemaining >= makerDeliverAmount` and revert otherwise.\n- Ensure tokens from one pair/order cannot be used to pay another (separate vaults per pair, or rigorous reserved accounting with invariants).", "focus_areas": ["asset_management", "business_logic"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:34.908995+00:00", "code_visible": false}}
{"id": "ngp", "name": "NGP", "chain_id": 56, "block_number": 61515894, "target_contract": "0xd2F26200cD524dB097Cf4ab7cC2E5C38aB6ae5c9", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-09/NGP_exp.sol", "defihacklabs_vuln_type": "Price Manipulation", "exploit_file": "NGP_exp.sol", "evm_version": null, "exploit_timestamp": 1758135745, "native_token_price_usd": 981.4, "tags": [], "lost_amount_usd": 2000000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Token transfer logic debits the AMM pair balance and calls `sync()` during sells", "severity": "critical", "content": "On sells (`to == mainPair`), the overridden `_update` performs non-standard state changes against the UniswapV2 pair: it executes `super._update(mainPair, treasuryAddress, treasuryAmount)` and `super._update(mainPair, rewardPoolAddress, rewardAmount)`, i.e., it transfers tokens out of the pair contract address without the pair initiating a swap/mint/burn. This violates UniswapV2\u2019s core invariant that reserves are only modified through the pair\u2019s own functions, and that the pair\u2019s token balances should not be arbitrarily debited by third-party logic.\n\nThe subsequent `IUniswapV2Pair(mainPair).sync()` call forces the pair to overwrite its reserves to match these externally modified balances. As a result, any user-triggered sell can permanently change reserves and price without going through the AMM\u2019s constant-product accounting, enabling reserve/price manipulation and extraction of the paired asset (e.g., USDT) at unfavorable rates for LPs. Because this behavior is embedded in the ERC20 transfer path, it is permissionless to trigger and can be composed with other transfers/swaps to create highly profitable, hard-to-detect economic attacks.\n\nIn short: the token contract must not move funds out of the pair or force-resync reserves as a side effect of transfers.", "fix_description": "Remove all transfers that use `mainPair` as the sender inside `_update`, and delete the `IUniswapV2Pair(mainPair).sync()` call from transfer flow. Collect treasury/reward amounts from the seller (`from`) (fee-on-transfer) or accumulate fees in the token contract and distribute/swap them via an explicit function. Concretely, replace:\n- `super._update(mainPair, treasuryAddress, treasuryAmount)` with `super._update(from, treasuryAddress, treasuryAmount)`\n- `super._update(mainPair, rewardPoolAddress, rewardAmount)` with `super._update(from, rewardPoolAddress, rewardAmount)`\n- remove `IUniswapV2Pair(mainPair).sync()` entirely.", "focus_areas": ["economic_attacks", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:22.742174+00:00", "code_visible": true}}
{"id": "sharwafinance", "name": "SharwaFinance", "chain_id": 42161, "block_number": 391402007, "target_contract": "0xd3fdE5AF30DA1F394d6e0D361B552648D0dff797", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-10/SharwaFinance_exp.sol", "defihacklabs_vuln_type": "Post Insolvency Check", "exploit_file": "SharwaFinance_exp.sol", "evm_version": null, "exploit_timestamp": 1760934747, "native_token_price_usd": 3981.1, "tags": [], "lost_amount_usd": 146.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Position close/settlement logic relies on manipulable on-chain swap quotes as trusted accounting inputs", "severity": "critical", "content": "FacadeTradeRouter determines how much debt to repay/borrow and how to route swaps during position closes and settlement using `facadeInput.getAmountOut(...)` and `facadeOutput.getAmountIn(...)` (e.g., in `_closePartialLongPosition`, `_closeFullLongPosition`, `_closePartialShortPosition`, `_closeFullShortPosition`, `fillSwapData`, `settlePositions`, and indirectly in `getMargin`). These functions are effectively spot AMM quotes that depend on instantaneous pool state. The router treats these values as authoritative for protocol accounting decisions (e.g., computing `repayAmount`, `leftAmount`, and swap paths) without manipulation resistance (no TWAP), sanity checks versus an external oracle, or user-enforced slippage bounds (notably, `amountOutMinimum` is frequently set to 0). As a result, any temporary price distortion in the referenced pools can cause the router to under-repay debt, miscompute how much collateral should be swapped/returned, or execute settlement at an adversarial price, enabling loss of funds and insolvency of margin accounts/protocol-owned balances. Because these quotes are used in core repayment/close mechanics, the impact is systemic and can be triggered within the same block as a swap that moves the pool price.", "fix_description": "Do not use spot AMM quotes for solvency/repay math. Compute repay/close amounts using a manipulation-resistant oracle (e.g., Chainlink, or Uniswap V3 TWAP over a sufficiently long window). Enforce strict slippage controls by requiring caller-provided `amountOutMinimum` / `amountInMaximum` (or per-swap bounds) and reverting if quotes deviate beyond configured thresholds vs oracle/TWAP. Additionally, add explicit price-impact/sanity checks (e.g., reject if AMM quote differs from oracle by >X%) before constructing/executing SwapData.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}, {"title": "Unsafe int256-to-uint256 casts in margin/close paths can corrupt repay and balance calculations", "severity": "high", "content": "Several flows treat signed position/collateral values returned by `oneClickProxy.getPosition()` (int256) as if they were always non-negative, and cast them directly to `uint256` without validating sign. Examples include `getMargin()` subtracting `uint(wethCollateralAmount)` / `uint(wbtcCollateralAmount)` for shorts, `decreaseLongPosition()` comparing `amount <= uint(positionSize)`, and `_closeFullShortPosition()` using `uint(collateralAmount)` as input to quote/swap planning. If any of these int256 values are negative (common when sign encodes direction), the cast can revert (Solidity 0.8+) or, depending on surrounding logic and mixed use of `convertToUint()` elsewhere, lead to inconsistent branch selection and incorrect repay/swap computations. This inconsistency between \u201craw cast\u201d and \u201cabsolute value\u201d handling can break invariants in close/settlement logic, and in the worst case can be leveraged to miscompute required repayment or the amount of assets to swap/return, resulting in incorrect accounting and potential loss of funds or inability to settle positions reliably.", "fix_description": "Eliminate all direct `uint(x)` casts from signed values. Normalize sign semantics: (1) enforce that collateral amounts are always non-negative via `require(collateralAmount >= 0)`; (2) for position sizes, always use `uint256(abs(positionSize))` via a single helper (e.g., `convertToUint`) and branch on `isLong` for direction. Replace every subtraction/comparison that uses `uint(int256)` with validated, sign-aware conversions and add bounds checks to prevent underflow/revert.", "focus_areas": ["arithmetic", "semantic_verification"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:56.913299+00:00", "code_visible": false}}
{"id": "tokenholder", "name": "TokenHolder", "chain_id": 56, "block_number": 63856734, "target_contract": "0x8c7f34436C0037742AeCf047e06fD4B27Ad01117", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-10/TokenHolder_exp.sol", "defihacklabs_vuln_type": "Access Control", "exploit_file": "TokenHolder_exp.sol", "evm_version": null, "exploit_timestamp": 1759891887, "native_token_price_usd": 1307.6, "tags": [], "lost_amount_usd": 20.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "sell() performs untrusted external calls using user-supplied TokenHolder and router addresses", "severity": "critical", "content": "BorrowerOperationsV6.sell() accepts both a TokenHolder instance and a swap router address as user-controlled parameters and then uses them for privileged protocol actions. The function first queries loan data via tokenHolder.loans(loanId) and proceeds without verifying that (a) the TokenHolder is the canonical/approved TokenHolder used by the protocol, or (b) the loan is a real loan created in that TokenHolder. This enables callers to supply a malicious TokenHolder that returns arbitrary crafted loan data (e.g., borrower, collateral token, amounts), bypassing any implicit \u201cloan existence\u201d assumptions.\n\nsell() then calls tokenHolder.privilegedLoan(...) and finally performs a raw low-level call to inchRouter.call(sellingCode) with attacker-controlled target and calldata. Because BorrowerOperationsV6 is expected to hold elevated permissions (e.g., BORROWER_ROUTER_ROLE) against the real TokenHolder and to custody WETH transiently during operations, this combination creates an arbitrary call gadget in a privileged context. An attacker can route execution to unexpected contracts/functions and manipulate approvals/transfers to steal funds held by TokenHolder or BorrowerOperationsV6, or force unintended token movements.\n\nThe intended protections (router/DEX whitelisting) are present but commented out, leaving no on-chain restriction on these critical addresses/calls.", "fix_description": "Remove user control over privileged counterparties and eliminate arbitrary call targets:\n- Store the canonical TokenHolder address in state (set in initialize) and remove the tokenHolder parameter from sell()/buy(), or require(tokenHolder == expectedTokenHolder).\n- Enforce strict allowlists for swap targets (router/DEX) and keep checks enabled (do not comment out): require(whitelistedDexes[inchRouter], ...).\n- Replace low-level call with a vetted router interface / adapter and validate the called router address; do not accept arbitrary calldata to arbitrary targets.\n- Add loan validity/ownership checks before any privileged action (e.g., require(loan.borrower == msg.sender) and sanity checks on amounts).", "focus_areas": ["input_validation", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:24:05.322042+00:00", "code_visible": false}}
{"id": "balancerv", "name": "BalancerV2", "chain_id": 1, "block_number": 23717396, "target_contract": "0xDACf5Fa19b1f720111609043ac67A9818262850c", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-11/BalancerV2_exp.sol", "defihacklabs_vuln_type": "Precision Loss", "exploit_file": "BalancerV2_exp.sol", "evm_version": null, "exploit_timestamp": 1762156007, "native_token_price_usd": 3603.83, "tags": [], "lost_amount_usd": 128000000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "GIVEN_OUT swap path performs non-conservative scaling/rounding when converting between scaled and raw token amounts (can undercharge amountIn)", "severity": "critical", "content": "The pool\u2019s EXACT_OUT (GIVEN_OUT) swap path computes the required input using StableMath in an \u201cupscaled\u201d precision domain (scaled balances / scalingFactors, potentially also incorporating rate caches in composable stable pools). It then converts the computed scaled input back into raw token units via downscaling and applies swap fees. When scaling factors exceed 1e18 (e.g., due to rate-provider-derived scaling), integer division at the scale-down boundary can round in the trader\u2019s favor: for some small/edge outputs, the raw `amountIn` returned by `_swapGivenOut` can be smaller than the true minimum input required to preserve the invariant after accounting for fees.\n\nThe Vault does not independently recompute pricing; it trusts the pool-returned `amountIn` and settles net deltas after `batchSwap`. As a result, repeated EXACT_OUT swaps can accumulate small per-swap undercharges into a material loss, allowing extraction of value from the pool without violating any explicit on-chain bounds.\n\nThis is a correctness issue in arithmetic and rounding direction across multiple conversions (raw->scaled, StableMath, scaled->raw, fee), not a reentrancy or access-control problem.", "fix_description": "Make rounding conservative for the pool across all conversion boundaries in GIVEN_OUT:\n- Use mul/div variants that round against the trader when converting raw amounts to scaled and scaled amounts back to raw (e.g., `mulUp` for scaling outputs, `divUp` when downscaling required inputs).\n- Apply fees in a way that preserves conservativeness (compute the pre-fee amount with `divUp`, then add fee, rather than rounding down then adding).\n- Add a post-condition check that the computed `amountIn` is sufficient: recompute the post-swap balances using raw amounts and require the invariant does not decrease beyond an explicitly bounded rounding epsilon.\n- Alternatively (defense-in-depth), disallow swaps below a minimum size when rate-derived scaling factors are used, or restructure math to carry extra precision and round only once at the end.", "focus_areas": ["arithmetic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:24:09.434788+00:00", "code_visible": false}}
{"id": "drlvaultv", "name": "DRLVaultV3", "chain_id": 1, "block_number": 23769386, "target_contract": "0x6A06707ab339BEE00C6663db17DdB422301ff5e8", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-11/DRLVaultV3_exp.sol", "defihacklabs_vuln_type": "Price Manipulation", "exploit_file": "DRLVaultV3_exp.sol", "evm_version": null, "exploit_timestamp": 1762784051, "native_token_price_usd": 3416.51, "tags": [], "lost_amount_usd": 100000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "swapToWETH() derives USDC/WETH quote from manipulable AMM spot price and does not enforce minimum output", "severity": "critical", "content": "The vault\u2019s USDC->WETH conversion in swapToWETH(uint256) relies on the instantaneous state of an AMM pool (e.g., UniswapV3/PancakeV3 slot0/tick/sqrtPriceX96) to determine the USDC/WETH rate used for the vault\u2019s trade. This design treats a DEX spot price as a trusted oracle even though it can be moved arbitrarily within a single transaction by sufficiently large swaps (including via flash liquidity/flash loans). Because swapToWETH does not protect the computed quote with a time-weighted average price (TWAP) or an independent oracle, and also does not enforce a minimum acceptable output (e.g., minOut = 0 / no slippage check), the vault can be forced to execute a swap at an extreme, transient price. As a result, the vault may sell USDC for substantially less WETH than fair value (or buy WETH at an inflated cost), creating a direct and potentially unbounded loss of vault assets whenever an attacker can manipulate the referenced pool price around the vault\u2019s swap execution.", "fix_description": "Do not use AMM spot price as the pricing source. Replace spot quoting with a TWAP (e.g., UniswapV3 OracleLibrary consult over a sufficiently long window) or a trusted external oracle (e.g., Chainlink). Add and enforce slippage protection: accept a `minAmountOut` parameter (or store a max-slippage BPS setting) and `require(amountOut >= minAmountOut, \"SLIPPAGE\")`; when calling a router, always pass a non-zero `amountOutMinimum` derived from TWAP and a max-slippage bound.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:23:42.139469+00:00", "code_visible": false}}
{"id": "yeth", "name": "yETH", "chain_id": 1, "block_number": 23914085, "target_contract": "0xCcd04073f4BdC4510927ea9Ba350875C3c65BF81", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-12/yETH_exp.sol", "defihacklabs_vuln_type": "Unsafe Math", "exploit_file": "yETH_exp.sol", "evm_version": null, "exploit_timestamp": 1764537107, "native_token_price_usd": 2799.09, "tags": [], "lost_amount_usd": 9000000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Virtual-balance accounting is not reconciled with actual ERC20 balances (fee-on-transfer/rebasing tokens break solvency)", "severity": "critical", "content": "The pool enforces its invariant and determines mint/burn/swap amounts using internally stored \u201cvirtual balances\u201d (vb) packed in `packed_vbs` and aggregated into `packed_pool_vb` (`vb_sum`/`vb_prod`). Across core user paths (`add_liquidity`, `swap`, `swap_exact_out`, `remove_liquidity`, `remove_liquidity_single`), these vbs are updated based on user-supplied amounts and rate-provider values, but the contract does not validate that the pool\u2019s *actual* ERC20 balances changed by the assumed amounts.\n\nIf an asset is rebasing (balance can change without transfers) or fee-on-transfer/deflationary (received amount < requested), the contract\u2019s vb state can diverge from reality. Once vb deviates, all subsequent calculations (LP minting, withdrawal quotes, and swap pricing) use incorrect balances, allowing withdrawals/swaps to be priced as if the pool holds more assets than it actually does, leading to insolvency and loss of funds. Management-only `skim()` is insufficient because user entrypoints never enforce post-transfer balance correctness, so the pool can be drained via normal user flows after desynchronization.", "fix_description": "Update vb using measured balance deltas, not user-provided amounts:\n- In `add_liquidity` and swap paths, snapshot `before = ERC20(asset).balanceOf(self)`, perform `transferFrom`, snapshot `after`, and set `received = after - before`; use `received` to compute `dvb` and vb updates.\n- For withdrawals, consider a `sync()` that recomputes vb from actual balances before any LP burn/transfer-out, or strictly disallow rebasing/fee-on-transfer tokens (explicit allowlist + invariant checks).\n- Add assertions that balance changes match expectations (within a tight tolerance) for supported assets.", "focus_areas": ["asset_management", "business_logic"], "auditable": true}, {"title": "`remove_liquidity` allows zero-LP withdrawals to mutate and recompute invariant state", "severity": "high", "content": "`remove_liquidity` does not validate `_lp_amount > 0`. As a result, `remove_liquidity(0, ...)` can still execute meaningful state transitions: it iterates all assets, rewrites each asset\u2019s packed vb state, and recomputes/overwrites the pool-wide aggregate invariant variables (`packed_pool_vb`, i.e., `vb_sum`/`vb_prod`). Even if the net vb deltas are intended to be zero, the function still \u201cre-anchors\u201d global accounting to whatever per-asset vb/rate/weight state exists at the time of the call.\n\nThis creates a free, user-accessible entrypoint to force invariant recomputation without burning LP. When combined with any condition that can desynchronize vb from actual balances (e.g., rebasing/fee-on-transfer behavior or rate updates), an attacker can repeatedly trigger state rebuilds to preserve/propagate a bad accounting state and then perform value-extractive actions (mint/burn or withdrawals) against the corrupted invariant.\n\nCorrectness should not rely on external LP token behavior for `burn(\u2026, 0)`; the pool must enforce its own input constraints.", "fix_description": "Add an explicit guard at the start of `remove_liquidity`:\n- `assert _lp_amount > 0, \"zero lp\"`\nAdditionally, avoid recomputing `packed_pool_vb`/rewriting `packed_vbs` when no state change is intended, and move any \u201crecompute/sync\u201d logic into a dedicated, access-controlled `sync()` function.", "focus_areas": ["input_validation", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:25:10.408724+00:00", "code_visible": false}}
{"id": "mttoken", "name": "MTToken", "chain_id": 56, "block_number": 74937079, "target_contract": "0x2f3f25046Ea518d1E524B8fB6147c656D6722CeD", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2026-01/MTToken_exp.sol", "defihacklabs_vuln_type": "Incorrect Fee Logic", "exploit_file": "MTToken_exp.sol", "evm_version": null, "exploit_timestamp": 1768205155, "native_token_price_usd": 904.97, "tags": [], "lost_amount_usd": 37000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Fee distribution does not bound cumulative contractor percentages, allowing fees to exceed the intended transfer fee", "severity": "critical", "content": "The custom fee mechanism in `ERC20Mintable.transactionFee()` calculates `transactFeeValue = amount * _transactFeeValue / 100` and then distributes that fee across `ContractorsFee[setType]` by looping over recipients and transferring `value = transactFeeValue * ContractorsFee[setType][i] / 100` to each `ContractorsAddress[setType][i]`. However, the implementation never enforces that the sum of `ContractorsFee[setType][i]` is <= 100, nor does it cap the total distributed amount to `transactFeeValue`. If the configured percentages sum to more than 100 (or are otherwise misconfigured), the loop will transfer more than `transactFeeValue` in total. Since these transfers are executed via `super._transfer(from, recipient, value)`, the sender is debited for all fee payouts, meaning the effective fee can exceed 100% of the advertised fee and even exceed the transfer amount. This breaks ERC20 transfer accounting assumptions and enables severe balance-drain scenarios for any address that performs transfers under fee logic (including contracts such as AMM pairs), potentially destabilizing integrations that rely on predictable balance changes.\n", "fix_description": "Enforce bounded fee configuration and cap distribution:\n- In `setContractorsFee()` (or before distributing), compute `sumPct = \u03a3 ContractorsFee[setType][i]` and `require(sumPct <= 100, \"fee pct sum > 100\")`.\n- Track `distributed += value` during the loop and `require(distributed <= transactFeeValue)`.\n- Optionally send `transactFeeValue - distributed` to a treasury address to handle rounding.\nAdditionally, consider explicitly exempting known AMM pair addresses from fees to avoid taxing pair-internal bookkeeping transfers.", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:24:27.599058+00:00", "code_visible": false}}
{"id": "prxvt", "name": "PRXVT", "chain_id": 8453, "block_number": 40229652, "target_contract": "0xDAc30a5e2612206E2756836Ed6764EC5817e6Fff", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2026-01/PRXVT_exp.sol", "defihacklabs_vuln_type": "Bussiness Logic Flaw", "exploit_file": "PRXVT_exp.sol", "evm_version": null, "exploit_timestamp": 1767248653, "native_token_price_usd": 2974.84, "tags": [], "lost_amount_usd": 97575.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Transferable receipt token does not update reward accounting, allowing rewards to be claimed multiple times for the same stake", "severity": "critical", "content": "The staking contract mints an ERC20 receipt token (stPRXVT) representing a share of staked principal and uses per-address reward accounting via `userRewardPerTokenPaid[account]` and `rewards[account]`. However, stPRXVT is freely transferable and the contract does not hook transfers to settle rewards for the sender/receiver. As a result, when stPRXVT is moved to an address whose reward state has never been updated, that recipient\u2019s `userRewardPerTokenPaid` remains at the default (0) and `rewards` is also 0, while `balanceOf(recipient)` now reflects the transferred stake. In `earned(account)`, the delta `(rewardPerToken() - userRewardPerTokenPaid[account])` is therefore computed as if the recipient had held the stake since inception, allowing the same underlying stake to \u201cre-accrue\u201d historical rewards again under a new address. Because `claimReward()` pays based on `earned(msg.sender)` and only updates accounting for `msg.sender`, repeated transfers to fresh addresses can repeatedly realize rewards against the same stake, draining the reward pool. Any boost mechanism stored per-address further increases the payout magnitude when combined with this accounting flaw.", "fix_description": "Either (A) make stPRXVT non-transferable (allow only mint/burn) by overriding ERC20 `_update(from,to,value)` and reverting when `from != address(0)` and `to != address(0)`, or (B) if transfers are intended, override `_update` and call `updateReward(from)` and `updateReward(to)` (settling `rewards[...]` and `userRewardPerTokenPaid[...]` at the current `rewardPerTokenStored`) before changing balances. Ensure transfer-time settlement uses the same `rewardPerToken()` snapshot as other state-changing paths.", "focus_areas": ["business_logic", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:24:24.976950+00:00", "code_visible": false}}
{"id": "makina", "name": "makina", "chain_id": 1, "block_number": 24273362, "target_contract": "0x6b006870C83b1Cd49E766Ac9209f8d68763Df721", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2026-01/makina_exp.sol", "defihacklabs_vuln_type": "Price Oracle Manipulation", "exploit_file": "makina_exp.sol", "evm_version": null, "exploit_timestamp": 1768880435, "native_token_price_usd": 2936.9, "tags": [], "lost_amount_usd": 5100000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "State-mutating AUM/position accounting updates are externally callable and trust manipulable AMM spot pricing", "severity": "critical", "content": "The protocol exposes functions that refresh core valuation/accounting state (e.g., total AUM and position valuation) such that any external caller can trigger these updates at arbitrary times. These updates derive prices/values from on-chain AMM pool state (e.g., Curve-style spot/near-spot reserves) without manipulation resistance (TWAP/medianization) or safety bounds. Because the newly written accounting values are treated as authoritative for subsequent mint/redeem/withdraw/exchange logic, an attacker can temporarily skew the referenced AMM price (even briefly within a single transaction/short window), then immediately force the protocol to \u201clock in\u201d the skewed valuation by calling the update functions, and finally interact with the protocol using the inflated valuation to extract real assets. The core code flaw is the combination of (1) globally stateful valuation updates callable by untrusted users and (2) reliance on manipulable AMM state as an oracle input without deviation limits or update cadence constraints. This creates a deterministic pathway to convert transient price distortion into persistent protocol state and direct loss of funds.", "fix_description": "Restrict all state-mutating valuation/accounting refresh entrypoints (e.g., `Machine.updateTotalAum()` and any state-changing `Caliber.accountForPosition(...)`) to trusted roles/keepers (`onlyRole`/`onlyOwner`/`restricted`). Replace AMM spot pricing with a manipulation-resistant oracle (e.g., sufficiently long TWAP, Chainlink feed, or medianized sources). Add guardrails: minimum update interval, max deviation checks vs last stored price, and circuit-breakers that reject updates during abnormal price movement. If user-triggered accounting is needed, make it view-only or scoped so it cannot globally reprice protocol assets.", "focus_areas": ["oracle_manipulation", "access_control"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:24:37.360089+00:00", "code_visible": false}}
{"id": "nalakuvara_lotteryticket50", "name": "Nalakuvara_LotteryTicket50", "chain_id": 8453, "block_number": 30001612, "target_contract": "0x172119155a48DE766B126de95c2cb331D3A5c7C2", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-05/Nalakuvara_LotteryTicket50_exp.sol", "defihacklabs_vuln_type": "Price Manipulation", "exploit_file": "Nalakuvara_LotteryTicket50_exp.sol", "evm_version": null, "exploit_timestamp": 1746792571, "native_token_price_usd": 2583.77, "tags": [], "lost_amount_usd": 105500.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Whitelist redemption branch transfers LP tokens from contract custody without enforcing per-user entitlement or burning LP", "severity": "critical", "content": "In `DestructionOfLotteryTickets`, the amount of LP to \u201credeem\u201d (`liquidityALL`) is computed from current pair reserves/totalSupply and an implied USDT amount. If `isWhiteListed[msg.sender]` is true, the function does not remove liquidity from the AMM and does not require the caller to provide LP tokens; instead it directly executes `IERC20(pairAddress).transfer(msg.sender, liquidityALL)` from the contract\u2019s own LP balance. There is no per-user accounting tying LP held by the contract to a specific user\u2019s deposits, and no cap preventing a whitelisted user from repeating calls to withdraw the entirety of the contract\u2019s LP holdings (bounded only by acquiring/burning tickets). Because this path pays out from shared protocol custody rather than redeeming from the pool, any whitelisted address can exfiltrate LP that backs other users, breaking solvency and enabling complete depletion of LP owned by the contract. The risk is amplified because `liquidityALL` is derived from manipulable on-chain reserves (see next finding), so the transferred LP amount may not reflect a fair value of the tickets burned.", "fix_description": "Remove the whitelist shortcut that transfers LP from contract custody. Always perform the same redemption logic for all users (remove liquidity and pay out redeemed assets), or if whitelisted users are intended to withdraw LP, require they supply LP via `transferFrom` and maintain strict per-user LP credit accounting (minted-on-deposit, debited-on-withdraw) so no caller can withdraw more LP than they are entitled to.", "focus_areas": ["business_logic", "asset_management"], "auditable": true}, {"title": "Redemption and deposit math rely on instantaneous Uniswap V2 reserves and near-zero slippage checks", "severity": "high", "content": "`transferToken` and `DestructionOfLotteryTickets` read spot reserves from the Uniswap V2 pair (`getReserves()`) and use them to derive value-critical amounts (e.g., target NATA amount to add liquidity, and LP amount to remove/transfer). These calculations implicitly treat current reserves as a reliable price oracle. However, AMM reserves can be temporarily skewed within a single transaction, so any mint/burn/redemption path that derives payouts from spot reserves is vulnerable to reserve manipulation. Compounding the issue, swaps and liquidity operations are executed with effectively no slippage protection (`amountOutMin = 1`, `amountAMin/amountBMin = 1`), ensuring operations proceed even at severely unfavorable/manipulated prices. As a result, a caller can force the contract to compute and execute with distorted amounts, enabling extraction of value far beyond what the intended economics allow and/or causing systemic insolvency for later redemptions.", "fix_description": "Do not use instantaneous reserves as an oracle for payout/mint/burn logic. Use a TWAP (e.g., Uniswap V2 cumulative price over a time window) or an external vetted oracle, and enforce meaningful slippage bounds (user-supplied or oracle-derived) for swaps and add/remove liquidity. Prefer accounting-based designs: base any LP redemption on actual LP tokens provided/credited and on amounts actually received from `removeLiquidity`, rather than reserve-derived estimates.", "focus_areas": ["oracle_manipulation", "economic_attacks"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:25:25.547102+00:00", "code_visible": true}}
{"id": "gmx", "name": "GMX", "chain_id": 42161, "block_number": 355878384, "target_contract": "0x489ee077994B6658eAfA855C308275EAd8097C4A", "defihacklabs_url": "https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2025-07/gmx_exp.sol", "defihacklabs_vuln_type": "Share price manipulation", "exploit_file": "gmx_exp.sol", "evm_version": null, "exploit_timestamp": 1752063747, "native_token_price_usd": 2951.31, "tags": [], "lost_amount_usd": 42000000.0, "dataset_version": "v2", "source_available": true, "status": "ready", "reference_findings": [{"title": "Global pricing-mode flags stored in contract state allow reentrancy to observe and act on transient inconsistent pricing configuration", "severity": "critical", "content": "The Vault\u2019s core accounting (PnL via getDelta, liquidation checks, collateral reductions, USDG mint/burn, and swaps) depends on getMinPrice/getMaxPrice, which delegate to an external IVaultPriceFeed.getPrice call. The Vault additionally uses mutable, contract-wide \u201cmode\u201d flags (e.g., includeAmmPrice and useSwapPricing) that alter how prices are computed, and multiple external entrypoints temporarily toggle these flags mid-execution (e.g., liquidatePosition sets includeAmmPrice=false then later restores it; swap/sellUSDG set useSwapPricing=true then later restore it; buyUSDG restores useSwapPricing=false).\n\nBecause pricing is not a pure/view operation (it involves an external call) and the mode flags are stored globally, any reentrant call path (direct reentrancy via the price feed, or indirect reentrancy via callback-capable upstream integrations) can invoke other Vault functions while the Vault is in a transient pricing mode. This breaks the implicit assumption that all calculations within a function use a consistent pricing configuration, enabling inconsistent PnL/fee/liquidation accounting and ultimately allowing incorrect settlement that can extract value from the pool.\n\nThis is a single-transaction integrity issue: even if the flags are \u201crestored\u201d at the end, reentrancy allows other actions to execute before restoration, while state is inconsistent.", "fix_description": "1) Remove global pricing-mode flags from storage. Pass pricing configuration as function parameters through the call stack (memory-only context), e.g., getPrice(token, maximise, includeAmmPrice, useSwapPricing), and avoid writing temporary modes to storage.\n2) Add nonReentrant protection to all externally callable, state-changing functions that can be reached during order execution/callback graphs (swap, buyUSDG, sellUSDG, increasePosition, decreasePosition, liquidatePosition, etc.).\n3) Treat the price feed as untrusted: snapshot required oracle values at the start of sensitive functions and use only the snapshot for the remainder of execution; avoid any external calls during critical accounting sections.", "focus_areas": ["reentrancy", "execution_flow"], "auditable": true}], "enrichment_metadata": {"model": "gpt-5.2", "timestamp": "2026-02-18T16:25:13.841141+00:00", "code_visible": false}}
